{
    "GeometryNodeAccumulateField": {
      "GeometryNodeAccumulateField": {
        "inputs": [
          "0: Value [Float]",
          "1: Group ID [Int]"
        ],
        "outputs": [
          "0: Leading [Float]",
          "1: Trailing [Float]",
          "2: Total [Float]"
        ],
        "description": "Add the values of an evaluated field together and output the running total for each element"
      }
    },
    "GeometryNodeAttributeDomainSize": {
      "GeometryNodeAttributeDomainSize": {
        "inputs": [
          "0: Geometry [Geometry]"
        ],
        "outputs": [
          "0: Point Count [Int]",
          "1: Edge Count [Int]",
          "2: Face Count [Int]",
          "3: Face Corner Count [Int]",
          "4: Spline Count [Int]",
          "5: Instance Count [Int]",
          "6: Layer Count [Int]"
        ],
        "description": "Retrieve the number of elements in a geometry for each attribute domain"
      }
    },
    "GeometryNodeAttributeStatistic": {
      "GeometryNodeAttributeStatistic": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Attribute [Float]"
        ],
        "outputs": [
          "0: Mean [Float]",
          "1: Median [Float]",
          "2: Sum [Float]",
          "3: Min [Float]",
          "4: Max [Float]",
          "5: Range [Float]",
          "6: Standard Deviation [Float]",
          "7: Variance [Float]"
        ],
        "description": "Calculate statistics about a data set from a field evaluated on a geometry"
      }
    },
    "GeometryNodeBake": {
      "GeometryNodeBake": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1:  [Virtual]"
        ],
        "outputs": [
          "0: Geometry [Geometry]",
          "1:  [Virtual]"
        ],
        "description": "Cache the incoming data so that it can be used without recomputation"
      }
    },
    "GeometryNodeBlurAttribute": {
      "GeometryNodeBlurAttribute": {
        "inputs": [
          "0: Value [Float]",
          "1: Iterations [Int]",
          "2: Weight [FloatFactor]"
        ],
        "outputs": [
          "0: Value [Float]"
        ],
        "description": "Mix attribute values of neighboring elements"
      }
    },
    "GeometryNodeBoundBox": {
      "GeometryNodeBoundBox": {
        "inputs": [
          "0: Geometry [Geometry]"
        ],
        "outputs": [
          "0: Bounding Box [Geometry]",
          "1: Min [Vector]",
          "2: Max [Vector]"
        ],
        "description": "Calculate the limits of a geometry's positions and generate a box mesh with those dimensions"
      }
    },
    "GeometryNodeCaptureAttribute": {
      "GeometryNodeCaptureAttribute": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1:  [Virtual]"
        ],
        "outputs": [
          "0: Geometry [Geometry]",
          "1:  [Virtual]"
        ],
        "description": "Store the result of a field on a geometry and output the data as a node socket. Allows remembering or interpolating data as the geometry changes, such as positions before deformation"
      }
    },
    "GeometryNodeCollectionInfo": {
      "GeometryNodeCollectionInfo": {
        "inputs": [
          "0: Collection [Collection]",
          "1: Separate Children [Bool]",
          "2: Reset Children [Bool]"
        ],
        "outputs": [
          "0: Instances [Geometry]"
        ],
        "description": "Retrieve geometry instances from a collection"
      }
    },
    "GeometryNodeConvexHull": {
      "GeometryNodeConvexHull": {
        "inputs": [
          "0: Geometry [Geometry]"
        ],
        "outputs": [
          "0: Convex Hull [Geometry]"
        ],
        "description": "Create a mesh that encloses all points in the input geometry with the smallest number of points"
      }
    },
    "GeometryNodeCornersOfEdge": {
      "GeometryNodeCornersOfEdge": {
        "inputs": [
          "0: Edge Index [Int]",
          "1: Weights [Float]",
          "2: Sort Index [Int]"
        ],
        "outputs": [
          "0: Corner Index [Int]",
          "1: Total [Int]"
        ],
        "description": "Retrieve face corners connected to edges"
      }
    },
    "GeometryNodeCornersOfFace": {
      "GeometryNodeCornersOfFace": {
        "inputs": [
          "0: Face Index [Int]",
          "1: Weights [Float]",
          "2: Sort Index [Int]"
        ],
        "outputs": [
          "0: Corner Index [Int]",
          "1: Total [Int]"
        ],
        "description": "Retrieve corners that make up a face"
      }
    },
    "GeometryNodeCornersOfVertex": {
      "GeometryNodeCornersOfVertex": {
        "inputs": [
          "0: Vertex Index [Int]",
          "1: Weights [Float]",
          "2: Sort Index [Int]"
        ],
        "outputs": [
          "0: Corner Index [Int]",
          "1: Total [Int]"
        ],
        "description": "Retrieve face corners connected to vertices"
      }
    },
    "GeometryNodeCurveArc": {
      "GeometryNodeCurveArc": {
        "inputs": [
          "0: Resolution [IntUnsigned]",
          "1: Start [VectorTranslation]",
          "2: Middle [VectorTranslation]",
          "3: End [VectorTranslation]",
          "4: Radius [FloatDistance]",
          "5: Start Angle [FloatAngle]",
          "6: Sweep Angle [FloatAngle]",
          "7: Offset Angle [FloatAngle]",
          "8: Connect Center [Bool]",
          "9: Invert Arc [Bool]"
        ],
        "outputs": [
          "0: Curve [Geometry]",
          "1: Center [Vector]",
          "2: Normal [Vector]",
          "3: Radius [Float]"
        ],
        "description": "Generate a poly spline arc"
      }
    },
    "GeometryNodeCurveEndpointSelection": {
      "GeometryNodeCurveEndpointSelection": {
        "inputs": [
          "0: Start Size [Int]",
          "1: End Size [Int]"
        ],
        "outputs": [
          "0: Selection [Bool]"
        ],
        "description": "Provide a selection for an arbitrary number of endpoints in each spline"
      }
    },
    "GeometryNodeCurveHandleTypeSelection": {
      "GeometryNodeCurveHandleTypeSelection": {
        "inputs": [],
        "outputs": [
          "0: Selection [Bool]"
        ],
        "description": "Provide a selection based on the handle types of B\u00e9zier control points"
      }
    },
    "GeometryNodeCurveLength": {
      "GeometryNodeCurveLength": {
        "inputs": [
          "0: Curve [Geometry]"
        ],
        "outputs": [
          "0: Length [Float]"
        ],
        "description": "Retrieve the length of all splines added together"
      }
    },
    "GeometryNodeCurveOfPoint": {
      "GeometryNodeCurveOfPoint": {
        "inputs": [
          "0: Point Index [Int]"
        ],
        "outputs": [
          "0: Curve Index [Int]",
          "1: Index in Curve [Int]"
        ],
        "description": "Retrieve the curve a control point is part of"
      }
    },
    "GeometryNodeCurvePrimitiveBezierSegment": {
      "GeometryNodeCurvePrimitiveBezierSegment": {
        "inputs": [
          "0: Resolution [IntUnsigned]",
          "1: Start [VectorTranslation]",
          "2: Start Handle [VectorTranslation]",
          "3: End Handle [VectorTranslation]",
          "4: End [VectorTranslation]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Generate a 2D B\u00e9zier spline from the given control points and handles"
      }
    },
    "GeometryNodeCurvePrimitiveCircle": {
      "GeometryNodeCurvePrimitiveCircle": {
        "inputs": [
          "0: Resolution [Int]",
          "1: Point 1 [VectorTranslation]",
          "2: Point 2 [VectorTranslation]",
          "3: Point 3 [VectorTranslation]",
          "4: Radius [FloatDistance]"
        ],
        "outputs": [
          "0: Curve [Geometry]",
          "1: Center [Vector]"
        ],
        "description": "Generate a poly spline circle"
      }
    },
    "GeometryNodeCurvePrimitiveLine": {
      "GeometryNodeCurvePrimitiveLine": {
        "inputs": [
          "0: Start [VectorTranslation]",
          "1: End [VectorTranslation]",
          "2: Direction [Vector]",
          "3: Length [FloatDistance]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Generate a poly spline line with two points"
      }
    },
    "GeometryNodeCurvePrimitiveQuadrilateral": {
      "GeometryNodeCurvePrimitiveQuadrilateral": {
        "inputs": [
          "0: Width [FloatDistance]",
          "1: Height [FloatDistance]",
          "2: Bottom Width [FloatDistance]",
          "3: Top Width [FloatDistance]",
          "4: Offset [FloatDistance]",
          "5: Bottom Height [FloatDistance]",
          "6: Top Height [FloatDistance]",
          "7: Point 1 [VectorTranslation]",
          "8: Point 2 [VectorTranslation]",
          "9: Point 3 [VectorTranslation]",
          "10: Point 4 [VectorTranslation]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Generate a polygon with four points"
      }
    },
    "GeometryNodeCurveQuadraticBezier": {
      "GeometryNodeCurveQuadraticBezier": {
        "inputs": [
          "0: Resolution [IntUnsigned]",
          "1: Start [VectorTranslation]",
          "2: Middle [VectorTranslation]",
          "3: End [VectorTranslation]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Generate a poly spline in a parabola shape with control points positions"
      }
    },
    "GeometryNodeCurveSetHandles": {
      "GeometryNodeCurveSetHandles": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Set the handle type for the control points of a B\u00e9zier curve"
      }
    },
    "GeometryNodeCurveSpiral": {
      "GeometryNodeCurveSpiral": {
        "inputs": [
          "0: Resolution [IntUnsigned]",
          "1: Rotations [Float]",
          "2: Start Radius [FloatDistance]",
          "3: End Radius [FloatDistance]",
          "4: Height [FloatDistance]",
          "5: Reverse [Bool]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Generate a poly spline in a spiral shape"
      }
    },
    "GeometryNodeCurveSplineType": {
      "GeometryNodeCurveSplineType": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Change the type of curves"
      }
    },
    "GeometryNodeCurveStar": {
      "GeometryNodeCurveStar": {
        "inputs": [
          "0: Points [IntUnsigned]",
          "1: Inner Radius [FloatDistance]",
          "2: Outer Radius [FloatDistance]",
          "3: Twist [FloatAngle]"
        ],
        "outputs": [
          "0: Curve [Geometry]",
          "1: Outer Points [Bool]"
        ],
        "description": "Generate a poly spline in a star pattern by connecting alternating points of two circles"
      }
    },
    "GeometryNodeCurveToMesh": {
      "GeometryNodeCurveToMesh": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Profile Curve [Geometry]",
          "2: Fill Caps [Bool]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Convert curves into a mesh, optionally with a custom profile shape defined by curves"
      }
    },
    "GeometryNodeCurveToPoints": {
      "GeometryNodeCurveToPoints": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Count [Int]",
          "2: Length [FloatDistance]"
        ],
        "outputs": [
          "0: Points [Geometry]",
          "1: Tangent [Vector]",
          "2: Normal [Vector]",
          "3: Rotation [Rotation]"
        ],
        "description": "Generate a point cloud by sampling positions along curves"
      }
    },
    "GeometryNodeCurvesToGreasePencil": {
      "GeometryNodeCurvesToGreasePencil": {
        "inputs": [
          "0: Curves [Geometry]",
          "1: Selection [Bool]",
          "2: Instances as Layers [Bool]"
        ],
        "outputs": [
          "0: Grease Pencil [Geometry]"
        ],
        "description": "Convert the curves in each top-level instance into Grease Pencil layer"
      }
    },
    "GeometryNodeDeformCurvesOnSurface": {
      "GeometryNodeDeformCurvesOnSurface": {
        "inputs": [
          "0: Curves [Geometry]"
        ],
        "outputs": [
          "0: Curves [Geometry]"
        ],
        "description": "Translate and rotate curves based on changes between the object's original and evaluated surface mesh"
      }
    },
    "GeometryNodeDeleteGeometry": {
      "GeometryNodeDeleteGeometry": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Remove selected elements of a geometry"
      }
    },
    "GeometryNodeDistributePointsInGrid": {
      "GeometryNodeDistributePointsInGrid": {
        "inputs": [
          "0: Grid [Float]",
          "1: Density [Float]",
          "2: Seed [Int]",
          "3: Spacing [VectorXYZ]",
          "4: Threshold [Float]"
        ],
        "outputs": [
          "0: Points [Geometry]"
        ],
        "description": "Generate points inside a volume grid"
      }
    },
    "GeometryNodeDistributePointsInVolume": {
      "GeometryNodeDistributePointsInVolume": {
        "inputs": [
          "0: Volume [Geometry]",
          "1: Density [Float]",
          "2: Seed [Int]",
          "3: Spacing [VectorXYZ]",
          "4: Threshold [Float]"
        ],
        "outputs": [
          "0: Points [Geometry]"
        ],
        "description": "Generate points inside a volume"
      }
    },
    "GeometryNodeDistributePointsOnFaces": {
      "GeometryNodeDistributePointsOnFaces": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Selection [Bool]",
          "2: Distance Min [FloatDistance]",
          "3: Density Max [Float]",
          "4: Density [Float]",
          "5: Density Factor [FloatFactor]",
          "6: Seed [Int]"
        ],
        "outputs": [
          "0: Points [Geometry]",
          "1: Normal [Vector]",
          "2: Rotation [Rotation]"
        ],
        "description": "Generate points spread out on the surface of a mesh"
      }
    },
    "GeometryNodeDualMesh": {
      "GeometryNodeDualMesh": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Keep Boundaries [Bool]"
        ],
        "outputs": [
          "0: Dual Mesh [Geometry]"
        ],
        "description": "Convert Faces into vertices and vertices into faces"
      }
    },
    "GeometryNodeDuplicateElements": {
      "GeometryNodeDuplicateElements": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Amount [Int]"
        ],
        "outputs": [
          "0: Geometry [Geometry]",
          "1: Duplicate Index [Int]"
        ],
        "description": "Generate an arbitrary number copies of each selected input element"
      }
    },
    "GeometryNodeEdgePathsToCurves": {
      "GeometryNodeEdgePathsToCurves": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Start Vertices [Bool]",
          "2: Next Vertex Index [Int]"
        ],
        "outputs": [
          "0: Curves [Geometry]"
        ],
        "description": "Output curves following paths across mesh edges"
      }
    },
    "GeometryNodeEdgePathsToSelection": {
      "GeometryNodeEdgePathsToSelection": {
        "inputs": [
          "0: Start Vertices [Bool]",
          "1: Next Vertex Index [Int]"
        ],
        "outputs": [
          "0: Selection [Bool]"
        ],
        "description": "Output a selection of edges by following paths across mesh edges"
      }
    },
    "GeometryNodeEdgesOfCorner": {
      "GeometryNodeEdgesOfCorner": {
        "inputs": [
          "0: Corner Index [Int]"
        ],
        "outputs": [
          "0: Next Edge Index [Int]",
          "1: Previous Edge Index [Int]"
        ],
        "description": "Retrieve the edges on both sides of a face corner"
      }
    },
    "GeometryNodeEdgesOfVertex": {
      "GeometryNodeEdgesOfVertex": {
        "inputs": [
          "0: Vertex Index [Int]",
          "1: Weights [Float]",
          "2: Sort Index [Int]"
        ],
        "outputs": [
          "0: Edge Index [Int]",
          "1: Total [Int]"
        ],
        "description": "Retrieve the edges connected to each vertex"
      }
    },
    "GeometryNodeEdgesToFaceGroups": {
      "GeometryNodeEdgesToFaceGroups": {
        "inputs": [
          "0: Boundary Edges [Bool]"
        ],
        "outputs": [
          "0: Face Group ID [Int]"
        ],
        "description": "Group faces into regions surrounded by the selected boundary edges"
      }
    },
    "GeometryNodeExtrudeMesh": {
      "GeometryNodeExtrudeMesh": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Selection [Bool]",
          "2: Offset [VectorTranslation]",
          "3: Offset Scale [Float]",
          "4: Individual [Bool]"
        ],
        "outputs": [
          "0: Mesh [Geometry]",
          "1: Top [Bool]",
          "2: Side [Bool]"
        ],
        "description": "Generate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary"
      }
    },
    "GeometryNodeFaceOfCorner": {
      "GeometryNodeFaceOfCorner": {
        "inputs": [
          "0: Corner Index [Int]"
        ],
        "outputs": [
          "0: Face Index [Int]",
          "1: Index in Face [Int]"
        ],
        "description": "Retrieve the face each face corner is part of"
      }
    },
    "GeometryNodeFieldAtIndex": {
      "GeometryNodeFieldAtIndex": {
        "inputs": [
          "0: Index [Int]",
          "1: Value [Float]"
        ],
        "outputs": [
          "0: Value [Float]"
        ],
        "description": "Retrieve data of other elements in the context's geometry"
      }
    },
    "GeometryNodeFieldOnDomain": {
      "GeometryNodeFieldOnDomain": {
        "inputs": [
          "0: Value [Float]"
        ],
        "outputs": [
          "0: Value [Float]"
        ],
        "description": "Retrieve values from a field on a different domain besides the domain from the context"
      }
    },
    "GeometryNodeFillCurve": {
      "GeometryNodeFillCurve": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Group ID [Int]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Generate a mesh on the XY plane with faces on the inside of input curves"
      }
    },
    "GeometryNodeFilletCurve": {
      "GeometryNodeFilletCurve": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Count [Int]",
          "2: Radius [FloatDistance]",
          "3: Limit Radius [Bool]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Round corners by generating circular arcs on each control point"
      }
    },
    "GeometryNodeFlipFaces": {
      "GeometryNodeFlipFaces": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Reverse the order of the vertices and edges of selected faces, flipping their normal direction"
      }
    },
    "GeometryNodeForeachGeometryElementInput": {
      "GeometryNodeForeachGeometryElementInput": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2:  [Virtual]"
        ],
        "outputs": [
          "0: Index [Int]",
          "1: Element [Geometry]",
          "2:  [Virtual]"
        ],
        "description": ""
      }
    },
    "GeometryNodeForeachGeometryElementOutput": {
      "GeometryNodeForeachGeometryElementOutput": {
        "inputs": [
          "0:  [Virtual]",
          "1: Geometry [Geometry]",
          "2:  [Virtual]"
        ],
        "outputs": [
          "0: Geometry [Geometry]",
          "1:  [Virtual]",
          "2: Geometry [Geometry]",
          "3:  [Virtual]"
        ],
        "description": ""
      }
    },
    "GeometryNodeGeometryToInstance": {
      "GeometryNodeGeometryToInstance": {
        "inputs": [
          "0: Geometry [Geometry]"
        ],
        "outputs": [
          "0: Instances [Geometry]"
        ],
        "description": "Convert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large"
      }
    },
    "GeometryNodeGetNamedGrid": {
      "GeometryNodeGetNamedGrid": {
        "inputs": [
          "0: Volume [Geometry]",
          "1: Name [String]",
          "2: Remove [Bool]"
        ],
        "outputs": [
          "0: Volume [Geometry]",
          "1: Grid [Float]"
        ],
        "description": "Get volume grid from a volume geometry with the specified name"
      }
    },
    "GeometryNodeGizmoDial": {
      "GeometryNodeGizmoDial": {
        "inputs": [
          "0: Value [Float]",
          "1: Position [VectorTranslation]",
          "2: Up [VectorXYZ]",
          "3: Screen Space [Bool]",
          "4: Radius [Float]"
        ],
        "outputs": [
          "0: Transform [Geometry]"
        ],
        "description": "Show a dial gizmo in the viewport for a value"
      }
    },
    "GeometryNodeGizmoLinear": {
      "GeometryNodeGizmoLinear": {
        "inputs": [
          "0: Value [Float]",
          "1: Position [VectorTranslation]",
          "2: Direction [VectorXYZ]"
        ],
        "outputs": [
          "0: Transform [Geometry]"
        ],
        "description": "Show a linear gizmo in the viewport for a value"
      }
    },
    "GeometryNodeGizmoTransform": {
      "GeometryNodeGizmoTransform": {
        "inputs": [
          "0: Value [Matrix]",
          "1: Position [VectorTranslation]",
          "2: Rotation [Rotation]"
        ],
        "outputs": [
          "0: Transform [Geometry]"
        ],
        "description": "Show a transform gizmo in the viewport"
      }
    },
    "GeometryNodeGreasePencilToCurves": {
      "GeometryNodeGreasePencilToCurves": {
        "inputs": [
          "0: Grease Pencil [Geometry]",
          "1: Selection [Bool]",
          "2: Layers as Instances [Bool]"
        ],
        "outputs": [
          "0: Curves [Geometry]"
        ],
        "description": "Convert Grease Pencil layers into curve instances"
      }
    },
    "GeometryNodeGridToMesh": {
      "GeometryNodeGridToMesh": {
        "inputs": [
          "0: Grid [Float]",
          "1: Threshold [Float]",
          "2: Adaptivity [FloatFactor]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Generate a mesh on the \"surface\" of a volume grid"
      }
    },
    "GeometryNodeGroup": {
      "GeometryNodeGroup": {
        "inputs": [],
        "outputs": [],
        "description": ""
      }
    },
    "GeometryNodeImageInfo": {
      "GeometryNodeImageInfo": {
        "inputs": [
          "0: Image [Image]",
          "1: Frame [Int]"
        ],
        "outputs": [
          "0: Width [Int]",
          "1: Height [Int]",
          "2: Has Alpha [Bool]",
          "3: Frame Count [Int]",
          "4: FPS [Float]"
        ],
        "description": "Retrieve information about an image"
      }
    },
    "GeometryNodeImageTexture": {
      "GeometryNodeImageTexture": {
        "inputs": [
          "0: Image [Image]",
          "1: Vector [Vector]",
          "2: Frame [Int]"
        ],
        "outputs": [
          "0: Color [Color]",
          "1: Alpha [Float]"
        ],
        "description": "Sample values from an image texture"
      }
    },
    "GeometryNodeImportOBJ": {
      "GeometryNodeImportOBJ": {
        "inputs": [
          "0: Path [StringFilePath]"
        ],
        "outputs": [
          "0: Instances [Geometry]"
        ],
        "description": "Import geometry from an OBJ file"
      }
    },
    "GeometryNodeImportPLY": {
      "GeometryNodeImportPLY": {
        "inputs": [
          "0: Path [StringFilePath]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Import a point cloud from a PLY file"
      }
    },
    "GeometryNodeImportSTL": {
      "GeometryNodeImportSTL": {
        "inputs": [
          "0: Path [StringFilePath]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Import a mesh from an STL file"
      }
    },
    "GeometryNodeIndexOfNearest": {
      "GeometryNodeIndexOfNearest": {
        "inputs": [
          "0: Position [Vector]",
          "1: Group ID [Int]"
        ],
        "outputs": [
          "0: Index [Int]",
          "1: Has Neighbor [Bool]"
        ],
        "description": "Find the nearest element in a group. Similar to the \"Sample Nearest\" node"
      }
    },
    "GeometryNodeIndexSwitch": {
      "GeometryNodeIndexSwitch": {
        "inputs": [
          "0: Index [Int]",
          "1: 0 [Geometry]",
          "2: 1 [Geometry]",
          "3:  [Virtual]"
        ],
        "outputs": [
          "0: Output [Geometry]"
        ],
        "description": "Choose between an arbitrary number of values with an index"
      }
    },
    "GeometryNodeInputActiveCamera": {
      "GeometryNodeInputActiveCamera": {
        "inputs": [],
        "outputs": [
          "0: Active Camera [Object]"
        ],
        "description": "Retrieve the scene's active camera"
      }
    },
    "GeometryNodeInputCollection": {
      "GeometryNodeInputCollection": {
        "inputs": [],
        "outputs": [
          "0: Collection [Collection]"
        ],
        "description": "Output a single collection"
      }
    },
    "GeometryNodeInputCurveHandlePositions": {
      "GeometryNodeInputCurveHandlePositions": {
        "inputs": [
          "0: Relative [Bool]"
        ],
        "outputs": [
          "0: Left [Vector]",
          "1: Right [Vector]"
        ],
        "description": "Retrieve the position of each B\u00e9zier control point's handles"
      }
    },
    "GeometryNodeInputCurveTilt": {
      "GeometryNodeInputCurveTilt": {
        "inputs": [],
        "outputs": [
          "0: Tilt [Float]"
        ],
        "description": "Retrieve the angle at each control point used to twist the curve's normal around its tangent"
      }
    },
    "GeometryNodeInputEdgeSmooth": {
      "GeometryNodeInputEdgeSmooth": {
        "inputs": [],
        "outputs": [
          "0: Smooth [Bool]"
        ],
        "description": "Retrieve whether each edge is marked for smooth or split normals"
      }
    },
    "GeometryNodeInputID": {
      "GeometryNodeInputID": {
        "inputs": [],
        "outputs": [
          "0: ID [Int]"
        ],
        "description": "Retrieve a stable random identifier value from the \"id\" attribute on the point domain, or the index if the attribute does not exist"
      }
    },
    "GeometryNodeInputImage": {
      "GeometryNodeInputImage": {
        "inputs": [],
        "outputs": [
          "0: Image [Image]"
        ],
        "description": "Input an image data-block"
      }
    },
    "GeometryNodeInputIndex": {
      "GeometryNodeInputIndex": {
        "inputs": [],
        "outputs": [
          "0: Index [Int]"
        ],
        "description": "Retrieve an integer value indicating the position of each element in the list, starting at zero"
      }
    },
    "GeometryNodeInputInstanceRotation": {
      "GeometryNodeInputInstanceRotation": {
        "inputs": [],
        "outputs": [
          "0: Rotation [Rotation]"
        ],
        "description": "Retrieve the rotation of each instance in the geometry"
      }
    },
    "GeometryNodeInputInstanceScale": {
      "GeometryNodeInputInstanceScale": {
        "inputs": [],
        "outputs": [
          "0: Scale [Vector]"
        ],
        "description": "Retrieve the scale of each instance in the geometry"
      }
    },
    "GeometryNodeInputMaterial": {
      "GeometryNodeInputMaterial": {
        "inputs": [],
        "outputs": [
          "0: Material [Material]"
        ],
        "description": "Output a single material"
      }
    },
    "GeometryNodeInputMaterialIndex": {
      "GeometryNodeInputMaterialIndex": {
        "inputs": [],
        "outputs": [
          "0: Material Index [Int]"
        ],
        "description": "Retrieve the index of the material used for each element in the geometry's list of materials"
      }
    },
    "GeometryNodeInputMeshEdgeAngle": {
      "GeometryNodeInputMeshEdgeAngle": {
        "inputs": [],
        "outputs": [
          "0: Unsigned Angle [Float]",
          "1: Signed Angle [Float]"
        ],
        "description": "The angle between the normals of connected manifold faces"
      }
    },
    "GeometryNodeInputMeshEdgeNeighbors": {
      "GeometryNodeInputMeshEdgeNeighbors": {
        "inputs": [],
        "outputs": [
          "0: Face Count [Int]"
        ],
        "description": "Retrieve the number of faces that use each edge as one of their sides"
      }
    },
    "GeometryNodeInputMeshEdgeVertices": {
      "GeometryNodeInputMeshEdgeVertices": {
        "inputs": [],
        "outputs": [
          "0: Vertex Index 1 [Int]",
          "1: Vertex Index 2 [Int]",
          "2: Position 1 [Vector]",
          "3: Position 2 [Vector]"
        ],
        "description": "Retrieve topology information relating to each edge of a mesh"
      }
    },
    "GeometryNodeInputMeshFaceArea": {
      "GeometryNodeInputMeshFaceArea": {
        "inputs": [],
        "outputs": [
          "0: Area [Float]"
        ],
        "description": "Calculate the surface area of a mesh's faces"
      }
    },
    "GeometryNodeInputMeshFaceIsPlanar": {
      "GeometryNodeInputMeshFaceIsPlanar": {
        "inputs": [
          "0: Threshold [FloatDistance]"
        ],
        "outputs": [
          "0: Planar [Bool]"
        ],
        "description": "Retrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal"
      }
    },
    "GeometryNodeInputMeshFaceNeighbors": {
      "GeometryNodeInputMeshFaceNeighbors": {
        "inputs": [],
        "outputs": [
          "0: Vertex Count [Int]",
          "1: Face Count [Int]"
        ],
        "description": "Retrieve topology information relating to each face of a mesh"
      }
    },
    "GeometryNodeInputMeshIsland": {
      "GeometryNodeInputMeshIsland": {
        "inputs": [],
        "outputs": [
          "0: Island Index [Int]",
          "1: Island Count [Int]"
        ],
        "description": "Retrieve information about separate connected regions in a mesh"
      }
    },
    "GeometryNodeInputMeshVertexNeighbors": {
      "GeometryNodeInputMeshVertexNeighbors": {
        "inputs": [],
        "outputs": [
          "0: Vertex Count [Int]",
          "1: Face Count [Int]"
        ],
        "description": "Retrieve topology information relating to each vertex of a mesh"
      }
    },
    "GeometryNodeInputNamedAttribute": {
      "GeometryNodeInputNamedAttribute": {
        "inputs": [
          "0: Name [String]"
        ],
        "outputs": [
          "0: Attribute [Float]",
          "1: Exists [Bool]"
        ],
        "description": "Retrieve the data of a specified attribute"
      }
    },
    "GeometryNodeInputNamedLayerSelection": {
      "GeometryNodeInputNamedLayerSelection": {
        "inputs": [
          "0: Name [String]"
        ],
        "outputs": [
          "0: Selection [Bool]"
        ],
        "description": "Output a selection of a Grease Pencil layer"
      }
    },
    "GeometryNodeInputNormal": {
      "GeometryNodeInputNormal": {
        "inputs": [],
        "outputs": [
          "0: Normal [Vector]"
        ],
        "description": "Retrieve a unit length vector indicating the direction pointing away from the geometry at each element"
      }
    },
    "GeometryNodeInputObject": {
      "GeometryNodeInputObject": {
        "inputs": [],
        "outputs": [
          "0: Object [Object]"
        ],
        "description": "Output a single object"
      }
    },
    "GeometryNodeInputPosition": {
      "GeometryNodeInputPosition": {
        "inputs": [],
        "outputs": [
          "0: Position [Vector]"
        ],
        "description": "Retrieve a vector indicating the location of each element"
      }
    },
    "GeometryNodeInputRadius": {
      "GeometryNodeInputRadius": {
        "inputs": [],
        "outputs": [
          "0: Radius [Float]"
        ],
        "description": "Retrieve the radius at each point on curve or point cloud geometry"
      }
    },
    "GeometryNodeInputSceneTime": {
      "GeometryNodeInputSceneTime": {
        "inputs": [],
        "outputs": [
          "0: Seconds [Float]",
          "1: Frame [Float]"
        ],
        "description": "Retrieve the current time in the scene's animation in units of seconds or frames"
      }
    },
    "GeometryNodeInputShadeSmooth": {
      "GeometryNodeInputShadeSmooth": {
        "inputs": [],
        "outputs": [
          "0: Smooth [Bool]"
        ],
        "description": "Retrieve whether each face is marked for smooth or sharp normals"
      }
    },
    "GeometryNodeInputShortestEdgePaths": {
      "GeometryNodeInputShortestEdgePaths": {
        "inputs": [
          "0: End Vertex [Bool]",
          "1: Edge Cost [Float]"
        ],
        "outputs": [
          "0: Next Vertex Index [Int]",
          "1: Total Cost [Float]"
        ],
        "description": "Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge"
      }
    },
    "GeometryNodeInputSplineCyclic": {
      "GeometryNodeInputSplineCyclic": {
        "inputs": [],
        "outputs": [
          "0: Cyclic [Bool]"
        ],
        "description": "Retrieve whether each spline endpoint connects to the beginning"
      }
    },
    "GeometryNodeInputSplineResolution": {
      "GeometryNodeInputSplineResolution": {
        "inputs": [],
        "outputs": [
          "0: Resolution [Int]"
        ],
        "description": "Retrieve the number of evaluated points that will be generated for every control point on curves"
      }
    },
    "GeometryNodeInputTangent": {
      "GeometryNodeInputTangent": {
        "inputs": [],
        "outputs": [
          "0: Tangent [Vector]"
        ],
        "description": "Retrieve the direction of curves at each control point"
      }
    },
    "GeometryNodeInstanceOnPoints": {
      "GeometryNodeInstanceOnPoints": {
        "inputs": [
          "0: Points [Geometry]",
          "1: Selection [Bool]",
          "2: Instance [Geometry]",
          "3: Pick Instance [Bool]",
          "4: Instance Index [Int]",
          "5: Rotation [Rotation]",
          "6: Scale [VectorXYZ]"
        ],
        "outputs": [
          "0: Instances [Geometry]"
        ],
        "description": "Generate a reference to geometry at each of the input points, without duplicating its underlying data"
      }
    },
    "GeometryNodeInstanceTransform": {
      "GeometryNodeInstanceTransform": {
        "inputs": [],
        "outputs": [
          "0: Transform [Matrix]"
        ],
        "description": "Retrieve the full transformation of each instance in the geometry"
      }
    },
    "GeometryNodeInstancesToPoints": {
      "GeometryNodeInstancesToPoints": {
        "inputs": [
          "0: Instances [Geometry]",
          "1: Selection [Bool]",
          "2: Position [Vector]",
          "3: Radius [FloatDistance]"
        ],
        "outputs": [
          "0: Points [Geometry]"
        ],
        "description": "Generate points at the origins of instances.\nNote: Nested instances are not affected by this node"
      }
    },
    "GeometryNodeInterpolateCurves": {
      "GeometryNodeInterpolateCurves": {
        "inputs": [
          "0: Guide Curves [Geometry]",
          "1: Guide Up [Vector]",
          "2: Guide Group ID [Int]",
          "3: Points [Geometry]",
          "4: Point Up [Vector]",
          "5: Point Group ID [Int]",
          "6: Max Neighbors [Int]"
        ],
        "outputs": [
          "0: Curves [Geometry]",
          "1: Closest Index [Int]",
          "2: Closest Weight [Float]"
        ],
        "description": "Generate new curves on points by interpolating between existing curves"
      }
    },
    "GeometryNodeIsViewport": {
      "GeometryNodeIsViewport": {
        "inputs": [],
        "outputs": [
          "0: Is Viewport [Bool]"
        ],
        "description": "Retrieve whether the nodes are being evaluated for the viewport rather than the final render"
      }
    },
    "GeometryNodeJoinGeometry": {
      "GeometryNodeJoinGeometry": {
        "inputs": [
          "0: Geometry [Geometry]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Merge separately generated geometries into a single one"
      }
    },
    "GeometryNodeMaterialSelection": {
      "GeometryNodeMaterialSelection": {
        "inputs": [
          "0: Material [Material]"
        ],
        "outputs": [
          "0: Selection [Bool]"
        ],
        "description": "Provide a selection of faces that use the specified material"
      }
    },
    "GeometryNodeMenuSwitch": {
      "GeometryNodeMenuSwitch": {
        "inputs": [
          "0: Menu [Menu]",
          "1: A [Geometry]",
          "2: B [Geometry]",
          "3:  [Virtual]"
        ],
        "outputs": [
          "0: Output [Geometry]"
        ],
        "description": "Select from multiple inputs by name"
      }
    },
    "GeometryNodeMergeByDistance": {
      "GeometryNodeMergeByDistance": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Distance [FloatDistance]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Merge vertices or points within a given distance"
      }
    },
    "GeometryNodeMergeLayers": {
      "GeometryNodeMergeLayers": {
        "inputs": [
          "0: Grease Pencil [Geometry]",
          "1: Selection [Bool]",
          "2: Group ID [Int]"
        ],
        "outputs": [
          "0: Grease Pencil [Geometry]"
        ],
        "description": "Join groups of Grease Pencil layers into one"
      }
    },
    "GeometryNodeMeshBoolean": {
      "GeometryNodeMeshBoolean": {
        "inputs": [
          "0: Mesh 1 [Geometry]",
          "1: Mesh 2 [Geometry]",
          "2: Self Intersection [Bool]",
          "3: Hole Tolerant [Bool]"
        ],
        "outputs": [
          "0: Mesh [Geometry]",
          "1: Intersecting Edges [Bool]"
        ],
        "description": "Cut, subtract, or join multiple mesh inputs"
      }
    },
    "GeometryNodeMeshCircle": {
      "GeometryNodeMeshCircle": {
        "inputs": [
          "0: Vertices [Int]",
          "1: Radius [FloatDistance]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Generate a circular ring of edges"
      }
    },
    "GeometryNodeMeshCone": {
      "GeometryNodeMeshCone": {
        "inputs": [
          "0: Vertices [Int]",
          "1: Side Segments [Int]",
          "2: Fill Segments [Int]",
          "3: Radius Top [FloatDistance]",
          "4: Radius Bottom [FloatDistance]",
          "5: Depth [FloatDistance]"
        ],
        "outputs": [
          "0: Mesh [Geometry]",
          "1: Top [Bool]",
          "2: Bottom [Bool]",
          "3: Side [Bool]",
          "4: UV Map [Vector]"
        ],
        "description": "Generate a cone mesh"
      }
    },
    "GeometryNodeMeshCube": {
      "GeometryNodeMeshCube": {
        "inputs": [
          "0: Size [VectorTranslation]",
          "1: Vertices X [Int]",
          "2: Vertices Y [Int]",
          "3: Vertices Z [Int]"
        ],
        "outputs": [
          "0: Mesh [Geometry]",
          "1: UV Map [Vector]"
        ],
        "description": "Generate a cuboid mesh with variable side lengths and subdivisions"
      }
    },
    "GeometryNodeMeshCylinder": {
      "GeometryNodeMeshCylinder": {
        "inputs": [
          "0: Vertices [Int]",
          "1: Side Segments [Int]",
          "2: Fill Segments [Int]",
          "3: Radius [FloatDistance]",
          "4: Depth [FloatDistance]"
        ],
        "outputs": [
          "0: Mesh [Geometry]",
          "1: Top [Bool]",
          "2: Side [Bool]",
          "3: Bottom [Bool]",
          "4: UV Map [Vector]"
        ],
        "description": "Generate a cylinder mesh"
      }
    },
    "GeometryNodeMeshFaceSetBoundaries": {
      "GeometryNodeMeshFaceSetBoundaries": {
        "inputs": [
          "0: Face Group ID [Int]"
        ],
        "outputs": [
          "0: Boundary Edges [Bool]"
        ],
        "description": "Find edges on the boundaries between groups of faces with the same ID value"
      }
    },
    "GeometryNodeMeshGrid": {
      "GeometryNodeMeshGrid": {
        "inputs": [
          "0: Size X [FloatDistance]",
          "1: Size Y [FloatDistance]",
          "2: Vertices X [Int]",
          "3: Vertices Y [Int]"
        ],
        "outputs": [
          "0: Mesh [Geometry]",
          "1: UV Map [Vector]"
        ],
        "description": "Generate a planar mesh on the XY plane"
      }
    },
    "GeometryNodeMeshIcoSphere": {
      "GeometryNodeMeshIcoSphere": {
        "inputs": [
          "0: Radius [FloatDistance]",
          "1: Subdivisions [Int]"
        ],
        "outputs": [
          "0: Mesh [Geometry]",
          "1: UV Map [Vector]"
        ],
        "description": "Generate a spherical mesh that consists of equally sized triangles"
      }
    },
    "GeometryNodeMeshLine": {
      "GeometryNodeMeshLine": {
        "inputs": [
          "0: Count [Int]",
          "1: Resolution [FloatDistance]",
          "2: Start Location [VectorTranslation]",
          "3: Offset [VectorTranslation]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Generate vertices in a line and connect them with edges"
      }
    },
    "GeometryNodeMeshToCurve": {
      "GeometryNodeMeshToCurve": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Generate a curve from a mesh"
      }
    },
    "GeometryNodeMeshToDensityGrid": {
      "GeometryNodeMeshToDensityGrid": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Density [Float]",
          "2: Voxel Size [FloatDistance]",
          "3: Gradient Width [FloatDistance]"
        ],
        "outputs": [
          "0: Density Grid [Float]"
        ],
        "description": "Create a filled volume grid from a mesh"
      }
    },
    "GeometryNodeMeshToPoints": {
      "GeometryNodeMeshToPoints": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Selection [Bool]",
          "2: Position [Vector]",
          "3: Radius [FloatDistance]"
        ],
        "outputs": [
          "0: Points [Geometry]"
        ],
        "description": "Generate a point cloud from a mesh's vertices"
      }
    },
    "GeometryNodeMeshToSDFGrid": {
      "GeometryNodeMeshToSDFGrid": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Voxel Size [FloatDistance]",
          "2: Band Width [Int]"
        ],
        "outputs": [
          "0: SDF Grid [Float]"
        ],
        "description": "Create a signed distance volume grid from a mesh"
      }
    },
    "GeometryNodeMeshToVolume": {
      "GeometryNodeMeshToVolume": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Density [Float]",
          "2: Voxel Size [FloatDistance]",
          "3: Voxel Amount [Float]",
          "4: Interior Band Width [FloatDistance]"
        ],
        "outputs": [
          "0: Volume [Geometry]"
        ],
        "description": "Create a fog volume with the shape of the input mesh's surface"
      }
    },
    "GeometryNodeMeshUVSphere": {
      "GeometryNodeMeshUVSphere": {
        "inputs": [
          "0: Segments [Int]",
          "1: Rings [Int]",
          "2: Radius [FloatDistance]"
        ],
        "outputs": [
          "0: Mesh [Geometry]",
          "1: UV Map [Vector]"
        ],
        "description": "Generate a spherical mesh with quads, except for triangles at the top and bottom"
      }
    },
    "GeometryNodeObjectInfo": {
      "GeometryNodeObjectInfo": {
        "inputs": [
          "0: Object [Object]",
          "1: As Instance [Bool]"
        ],
        "outputs": [
          "0: Transform [Matrix]",
          "1: Location [Vector]",
          "2: Rotation [Rotation]",
          "3: Scale [Vector]",
          "4: Geometry [Geometry]"
        ],
        "description": "Retrieve information from an object"
      }
    },
    "GeometryNodeOffsetCornerInFace": {
      "GeometryNodeOffsetCornerInFace": {
        "inputs": [
          "0: Corner Index [Int]",
          "1: Offset [Int]"
        ],
        "outputs": [
          "0: Corner Index [Int]"
        ],
        "description": "Retrieve corners in the same face as another"
      }
    },
    "GeometryNodeOffsetPointInCurve": {
      "GeometryNodeOffsetPointInCurve": {
        "inputs": [
          "0: Point Index [Int]",
          "1: Offset [Int]"
        ],
        "outputs": [
          "0: Is Valid Offset [Bool]",
          "1: Point Index [Int]"
        ],
        "description": "Offset a control point index within its curve"
      }
    },
    "GeometryNodePoints": {
      "GeometryNodePoints": {
        "inputs": [
          "0: Count [Int]",
          "1: Position [VectorTranslation]",
          "2: Radius [FloatDistance]"
        ],
        "outputs": [
          "0: Points [Geometry]"
        ],
        "description": "Generate a point cloud with positions and radii defined by fields"
      }
    },
    "GeometryNodePointsOfCurve": {
      "GeometryNodePointsOfCurve": {
        "inputs": [
          "0: Curve Index [Int]",
          "1: Weights [Float]",
          "2: Sort Index [Int]"
        ],
        "outputs": [
          "0: Point Index [Int]",
          "1: Total [Int]"
        ],
        "description": "Retrieve a point index within a curve"
      }
    },
    "GeometryNodePointsToCurves": {
      "GeometryNodePointsToCurves": {
        "inputs": [
          "0: Points [Geometry]",
          "1: Curve Group ID [Int]",
          "2: Weight [Float]"
        ],
        "outputs": [
          "0: Curves [Geometry]"
        ],
        "description": "Split all points to curve by its group ID and reorder by weight"
      }
    },
    "GeometryNodePointsToSDFGrid": {
      "GeometryNodePointsToSDFGrid": {
        "inputs": [
          "0: Points [Geometry]",
          "1: Radius [FloatDistance]",
          "2: Voxel Size [FloatDistance]"
        ],
        "outputs": [
          "0: SDF Grid [Float]"
        ],
        "description": "Create a signed distance volume grid from points"
      }
    },
    "GeometryNodePointsToVertices": {
      "GeometryNodePointsToVertices": {
        "inputs": [
          "0: Points [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Generate a mesh vertex for each point cloud point"
      }
    },
    "GeometryNodePointsToVolume": {
      "GeometryNodePointsToVolume": {
        "inputs": [
          "0: Points [Geometry]",
          "1: Density [Float]",
          "2: Voxel Size [FloatDistance]",
          "3: Voxel Amount [Float]",
          "4: Radius [FloatDistance]"
        ],
        "outputs": [
          "0: Volume [Geometry]"
        ],
        "description": "Generate a fog volume sphere around every point"
      }
    },
    "GeometryNodeProximity": {
      "GeometryNodeProximity": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Group ID [Int]",
          "2: Sample Position [Vector]",
          "3: Sample Group ID [Int]"
        ],
        "outputs": [
          "0: Position [Vector]",
          "1: Distance [Float]",
          "2: Is Valid [Bool]"
        ],
        "description": "Compute the closest location on the target geometry"
      }
    },
    "GeometryNodeRaycast": {
      "GeometryNodeRaycast": {
        "inputs": [
          "0: Target Geometry [Geometry]",
          "1: Attribute [Float]",
          "2: Source Position [Vector]",
          "3: Ray Direction [Vector]",
          "4: Ray Length [FloatDistance]"
        ],
        "outputs": [
          "0: Is Hit [Bool]",
          "1: Hit Position [Vector]",
          "2: Hit Normal [Vector]",
          "3: Hit Distance [Float]",
          "4: Attribute [Float]"
        ],
        "description": "Cast rays from the context geometry onto a target geometry, and retrieve information from each hit point"
      }
    },
    "GeometryNodeRealizeInstances": {
      "GeometryNodeRealizeInstances": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Realize All [Bool]",
          "3: Depth [Int]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Convert instances into real geometry data"
      }
    },
    "GeometryNodeRemoveAttribute": {
      "GeometryNodeRemoveAttribute": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Name [String]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Delete an attribute with a specified name from a geometry. Typically used to optimize performance"
      }
    },
    "GeometryNodeRepeatInput": {
      "GeometryNodeRepeatInput": {
        "inputs": [
          "0: Iterations [Int]",
          "1:  [Virtual]"
        ],
        "outputs": [
          "0: Iteration [Int]",
          "1:  [Virtual]"
        ],
        "description": ""
      }
    },
    "GeometryNodeRepeatOutput": {
      "GeometryNodeRepeatOutput": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1:  [Virtual]"
        ],
        "outputs": [
          "0: Geometry [Geometry]",
          "1:  [Virtual]"
        ],
        "description": ""
      }
    },
    "GeometryNodeReplaceMaterial": {
      "GeometryNodeReplaceMaterial": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Old [Material]",
          "2: New [Material]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Swap one material with another"
      }
    },
    "GeometryNodeResampleCurve": {
      "GeometryNodeResampleCurve": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Selection [Bool]",
          "2: Count [Int]",
          "3: Length [FloatDistance]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Generate a poly spline for each input spline"
      }
    },
    "GeometryNodeReverseCurve": {
      "GeometryNodeReverseCurve": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Change the direction of curves by swapping their start and end data"
      }
    },
    "GeometryNodeRotateInstances": {
      "GeometryNodeRotateInstances": {
        "inputs": [
          "0: Instances [Geometry]",
          "1: Selection [Bool]",
          "2: Rotation [Rotation]",
          "3: Pivot Point [VectorTranslation]",
          "4: Local Space [Bool]"
        ],
        "outputs": [
          "0: Instances [Geometry]"
        ],
        "description": "Rotate geometry instances in local or global space"
      }
    },
    "GeometryNodeSDFGridBoolean": {
      "GeometryNodeSDFGridBoolean": {
        "inputs": [
          "0: Grid 1 [Float]",
          "1: Grid 2 [Float]"
        ],
        "outputs": [
          "0: Grid [Float]"
        ],
        "description": "Cut, subtract, or join multiple SDF volume grid inputs"
      }
    },
    "GeometryNodeSampleCurve": {
      "GeometryNodeSampleCurve": {
        "inputs": [
          "0: Curves [Geometry]",
          "1: Value [Float]",
          "2: Factor [FloatFactor]",
          "3: Length [FloatDistance]",
          "4: Curve Index [Int]"
        ],
        "outputs": [
          "0: Value [Float]",
          "1: Position [Vector]",
          "2: Tangent [Vector]",
          "3: Normal [Vector]"
        ],
        "description": "Retrieve data from a point on a curve at a certain distance from its start"
      }
    },
    "GeometryNodeSampleGrid": {
      "GeometryNodeSampleGrid": {
        "inputs": [
          "0: Grid [Float]",
          "1: Position [Vector]"
        ],
        "outputs": [
          "0: Value [Float]"
        ],
        "description": ""
      }
    },
    "GeometryNodeSampleGridIndex": {
      "GeometryNodeSampleGridIndex": {
        "inputs": [
          "0: Grid [Float]",
          "1: X [Int]",
          "2: Y [Int]",
          "3: Z [Int]"
        ],
        "outputs": [
          "0: Value [Float]"
        ],
        "description": "Retrieve volume grid values at specific voxels"
      }
    },
    "GeometryNodeSampleIndex": {
      "GeometryNodeSampleIndex": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Value [Float]",
          "2: Index [Int]"
        ],
        "outputs": [
          "0: Value [Float]"
        ],
        "description": "Retrieve values from specific geometry elements"
      }
    },
    "GeometryNodeSampleNearest": {
      "GeometryNodeSampleNearest": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Sample Position [Vector]"
        ],
        "outputs": [
          "0: Index [Int]"
        ],
        "description": "Find the element of a geometry closest to a position. Similar to the \"Index of Nearest\" node"
      }
    },
    "GeometryNodeSampleNearestSurface": {
      "GeometryNodeSampleNearestSurface": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Value [Float]",
          "2: Group ID [Int]",
          "3: Sample Position [Vector]",
          "4: Sample Group ID [Int]"
        ],
        "outputs": [
          "0: Value [Float]",
          "1: Is Valid [Bool]"
        ],
        "description": "Calculate the interpolated value of a mesh attribute on the closest point of its surface"
      }
    },
    "GeometryNodeSampleUVSurface": {
      "GeometryNodeSampleUVSurface": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Value [Float]",
          "2: UV Map [Vector]",
          "3: Sample UV [Vector]"
        ],
        "outputs": [
          "0: Value [Float]",
          "1: Is Valid [Bool]"
        ],
        "description": "Calculate the interpolated values of a mesh attribute at a UV coordinate"
      }
    },
    "GeometryNodeScaleElements": {
      "GeometryNodeScaleElements": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Scale [Float]",
          "3: Center [VectorTranslation]",
          "4: Axis [Vector]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Scale groups of connected edges and faces"
      }
    },
    "GeometryNodeScaleInstances": {
      "GeometryNodeScaleInstances": {
        "inputs": [
          "0: Instances [Geometry]",
          "1: Selection [Bool]",
          "2: Scale [VectorXYZ]",
          "3: Center [VectorTranslation]",
          "4: Local Space [Bool]"
        ],
        "outputs": [
          "0: Instances [Geometry]"
        ],
        "description": "Scale geometry instances in local or global space"
      }
    },
    "GeometryNodeSelfObject": {
      "GeometryNodeSelfObject": {
        "inputs": [],
        "outputs": [
          "0: Self Object [Object]"
        ],
        "description": "Retrieve the object that contains the geometry nodes modifier currently being executed"
      }
    },
    "GeometryNodeSeparateComponents": {
      "GeometryNodeSeparateComponents": {
        "inputs": [
          "0: Geometry [Geometry]"
        ],
        "outputs": [
          "0: Mesh [Geometry]",
          "1: Curve [Geometry]",
          "2: Grease Pencil [Geometry]",
          "3: Point Cloud [Geometry]",
          "4: Volume [Geometry]",
          "5: Instances [Geometry]"
        ],
        "description": "Split a geometry into a separate output for each type of data in the geometry"
      }
    },
    "GeometryNodeSeparateGeometry": {
      "GeometryNodeSeparateGeometry": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Selection [Geometry]",
          "1: Inverted [Geometry]"
        ],
        "description": "Split a geometry into two geometry outputs based on a selection"
      }
    },
    "GeometryNodeSetCurveHandlePositions": {
      "GeometryNodeSetCurveHandlePositions": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Selection [Bool]",
          "2: Position [Vector]",
          "3: Offset [Vector]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Set the positions for the handles of B\u00e9zier curves"
      }
    },
    "GeometryNodeSetCurveNormal": {
      "GeometryNodeSetCurveNormal": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Selection [Bool]",
          "2: Normal [VectorXYZ]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Set the evaluation mode for curve normals"
      }
    },
    "GeometryNodeSetCurveRadius": {
      "GeometryNodeSetCurveRadius": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Selection [Bool]",
          "2: Radius [FloatDistance]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Set the radius of the curve at each control point"
      }
    },
    "GeometryNodeSetCurveTilt": {
      "GeometryNodeSetCurveTilt": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Selection [Bool]",
          "2: Tilt [FloatAngle]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Set the tilt angle at each curve control point"
      }
    },
    "GeometryNodeSetGeometryName": {
      "GeometryNodeSetGeometryName": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Name [String]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Set the name of a geometry for easier debugging"
      }
    },
    "GeometryNodeSetID": {
      "GeometryNodeSetID": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: ID [Int]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Set the id attribute on the input geometry, mainly used internally for randomizing"
      }
    },
    "GeometryNodeSetInstanceTransform": {
      "GeometryNodeSetInstanceTransform": {
        "inputs": [
          "0: Instances [Geometry]",
          "1: Selection [Bool]",
          "2: Transform [Matrix]"
        ],
        "outputs": [
          "0: Instances [Geometry]"
        ],
        "description": "Set the transformation matrix of every instance"
      }
    },
    "GeometryNodeSetMaterial": {
      "GeometryNodeSetMaterial": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Material [Material]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Assign a material to geometry elements"
      }
    },
    "GeometryNodeSetMaterialIndex": {
      "GeometryNodeSetMaterialIndex": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Material Index [Int]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Set the material index for each selected geometry element"
      }
    },
    "GeometryNodeSetPointRadius": {
      "GeometryNodeSetPointRadius": {
        "inputs": [
          "0: Points [Geometry]",
          "1: Selection [Bool]",
          "2: Radius [FloatDistance]"
        ],
        "outputs": [
          "0: Points [Geometry]"
        ],
        "description": "Set the display size of point cloud points"
      }
    },
    "GeometryNodeSetPosition": {
      "GeometryNodeSetPosition": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Position [Vector]",
          "3: Offset [VectorTranslation]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Set the location of each point"
      }
    },
    "GeometryNodeSetShadeSmooth": {
      "GeometryNodeSetShadeSmooth": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Shade Smooth [Bool]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Control the smoothness of mesh normals around each face by changing the \"shade smooth\" attribute"
      }
    },
    "GeometryNodeSetSplineCyclic": {
      "GeometryNodeSetSplineCyclic": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Cyclic [Bool]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Control whether each spline loops back on itself by changing the \"cyclic\" attribute"
      }
    },
    "GeometryNodeSetSplineResolution": {
      "GeometryNodeSetSplineResolution": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Resolution [Int]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Control how many evaluated points should be generated on every curve segment"
      }
    },
    "GeometryNodeSimulationInput": {
      "GeometryNodeSimulationInput": {
        "inputs": [],
        "outputs": [
          "0: Delta Time [Float]"
        ],
        "description": "Input data for the simulation zone"
      }
    },
    "GeometryNodeSimulationOutput": {
      "GeometryNodeSimulationOutput": {
        "inputs": [
          "0: Skip [Bool]",
          "1: Geometry [Geometry]",
          "2:  [Virtual]"
        ],
        "outputs": [
          "0: Geometry [Geometry]",
          "1:  [Virtual]"
        ],
        "description": "Output data from the simulation zone"
      }
    },
    "GeometryNodeSortElements": {
      "GeometryNodeSortElements": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Group ID [Int]",
          "3: Sort Weight [Float]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Rearrange geometry elements, changing their indices"
      }
    },
    "GeometryNodeSplineLength": {
      "GeometryNodeSplineLength": {
        "inputs": [],
        "outputs": [
          "0: Length [Float]",
          "1: Point Count [Int]"
        ],
        "description": "Retrieve the total length of each spline, as a distance or as a number of points"
      }
    },
    "GeometryNodeSplineParameter": {
      "GeometryNodeSplineParameter": {
        "inputs": [],
        "outputs": [
          "0: Factor [Float]",
          "1: Length [Float]",
          "2: Index [Int]"
        ],
        "description": "Retrieve how far along each spline a control point is"
      }
    },
    "GeometryNodeSplitEdges": {
      "GeometryNodeSplitEdges": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Duplicate mesh edges and break connections with the surrounding faces"
      }
    },
    "GeometryNodeSplitToInstances": {
      "GeometryNodeSplitToInstances": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Group ID [Int]"
        ],
        "outputs": [
          "0: Instances [Geometry]",
          "1: Group ID [Int]"
        ],
        "description": "Create separate geometries containing the elements from the same group"
      }
    },
    "GeometryNodeStoreNamedAttribute": {
      "GeometryNodeStoreNamedAttribute": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]",
          "2: Name [String]",
          "3: Value [Float]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Store the result of a field on a geometry as an attribute with the specified name"
      }
    },
    "GeometryNodeStoreNamedGrid": {
      "GeometryNodeStoreNamedGrid": {
        "inputs": [
          "0: Volume [Geometry]",
          "1: Name [String]",
          "2: Grid [Float]"
        ],
        "outputs": [
          "0: Volume [Geometry]"
        ],
        "description": "Store grid data in a volume geometry with the specified name"
      }
    },
    "GeometryNodeStringJoin": {
      "GeometryNodeStringJoin": {
        "inputs": [
          "0: Delimiter [String]",
          "1: Strings [String]"
        ],
        "outputs": [
          "0: String [String]"
        ],
        "description": "Combine any number of input strings"
      }
    },
    "GeometryNodeStringToCurves": {
      "GeometryNodeStringToCurves": {
        "inputs": [
          "0: String [String]",
          "1: Size [FloatDistance]",
          "2: Character Spacing [Float]",
          "3: Word Spacing [Float]",
          "4: Line Spacing [Float]",
          "5: Text Box Width [FloatDistance]",
          "6: Text Box Height [FloatDistance]"
        ],
        "outputs": [
          "0: Curve Instances [Geometry]",
          "1: Remainder [String]",
          "2: Line [Int]",
          "3: Pivot Point [Vector]"
        ],
        "description": "Generate a paragraph of text with a specific font, using a curve instance to store each character"
      }
    },
    "GeometryNodeSubdivideCurve": {
      "GeometryNodeSubdivideCurve": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Cuts [Int]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Dividing each curve segment into a specified number of pieces"
      }
    },
    "GeometryNodeSubdivideMesh": {
      "GeometryNodeSubdivideMesh": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Level [Int]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Divide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices"
      }
    },
    "GeometryNodeSubdivisionSurface": {
      "GeometryNodeSubdivisionSurface": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Level [Int]",
          "2: Edge Crease [FloatFactor]",
          "3: Vertex Crease [FloatFactor]",
          "4: Limit Surface [Bool]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Divide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method"
      }
    },
    "GeometryNodeSwitch": {
      "GeometryNodeSwitch": {
        "inputs": [
          "0: Switch [Bool]",
          "1: False [Geometry]",
          "2: True [Geometry]"
        ],
        "outputs": [
          "0: Output [Geometry]"
        ],
        "description": "Switch between two inputs"
      }
    },
    "GeometryNodeTool3DCursor": {
      "GeometryNodeTool3DCursor": {
        "inputs": [],
        "outputs": [
          "0: Location [VectorTranslation]",
          "1: Rotation [Rotation]"
        ],
        "description": "The scene's 3D cursor location and rotation"
      }
    },
    "GeometryNodeToolActiveElement": {
      "GeometryNodeToolActiveElement": {
        "inputs": [],
        "outputs": [
          "0: Index [Int]",
          "1: Exists [Bool]"
        ],
        "description": "Active element indices of the edited geometry, for tool execution"
      }
    },
    "GeometryNodeToolFaceSet": {
      "GeometryNodeToolFaceSet": {
        "inputs": [],
        "outputs": [
          "0: Face Set [Int]",
          "1: Exists [Bool]"
        ],
        "description": "Each face's sculpt face set value"
      }
    },
    "GeometryNodeToolMousePosition": {
      "GeometryNodeToolMousePosition": {
        "inputs": [],
        "outputs": [
          "0: Mouse X [Int]",
          "1: Mouse Y [Int]",
          "2: Region Width [Int]",
          "3: Region Height [Int]"
        ],
        "description": "Retrieve the position of the mouse cursor"
      }
    },
    "GeometryNodeToolSelection": {
      "GeometryNodeToolSelection": {
        "inputs": [],
        "outputs": [
          "0: Boolean [Bool]",
          "1: Float [Float]"
        ],
        "description": "User selection of the edited geometry, for tool execution"
      }
    },
    "GeometryNodeToolSetFaceSet": {
      "GeometryNodeToolSetFaceSet": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Selection [Bool]",
          "2: Face Set [Int]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Set sculpt face set values for faces"
      }
    },
    "GeometryNodeToolSetSelection": {
      "GeometryNodeToolSetSelection": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Set selection of the edited geometry, for tool execution"
      }
    },
    "GeometryNodeTransform": {
      "GeometryNodeTransform": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Translation [VectorTranslation]",
          "2: Rotation [Rotation]",
          "3: Scale [VectorXYZ]",
          "4: Transform [Matrix]"
        ],
        "outputs": [
          "0: Geometry [Geometry]"
        ],
        "description": "Translate, rotate or scale the geometry"
      }
    },
    "GeometryNodeTranslateInstances": {
      "GeometryNodeTranslateInstances": {
        "inputs": [
          "0: Instances [Geometry]",
          "1: Selection [Bool]",
          "2: Translation [VectorTranslation]",
          "3: Local Space [Bool]"
        ],
        "outputs": [
          "0: Instances [Geometry]"
        ],
        "description": "Move top-level geometry instances in local or global space"
      }
    },
    "GeometryNodeTriangulate": {
      "GeometryNodeTriangulate": {
        "inputs": [
          "0: Mesh [Geometry]",
          "1: Selection [Bool]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Convert all faces in a mesh to triangular faces"
      }
    },
    "GeometryNodeTrimCurve": {
      "GeometryNodeTrimCurve": {
        "inputs": [
          "0: Curve [Geometry]",
          "1: Selection [Bool]",
          "2: Start [FloatFactor]",
          "3: End [FloatFactor]",
          "4: Start [FloatDistance]",
          "5: End [FloatDistance]"
        ],
        "outputs": [
          "0: Curve [Geometry]"
        ],
        "description": "Shorten curves by removing portions at the start or end"
      }
    },
    "GeometryNodeUVPackIslands": {
      "GeometryNodeUVPackIslands": {
        "inputs": [
          "0: UV [Vector]",
          "1: Selection [Bool]",
          "2: Margin [Float]",
          "3: Rotate [Bool]"
        ],
        "outputs": [
          "0: UV [Vector]"
        ],
        "description": "Scale islands of a UV map and move them so they fill the UV space as much as possible"
      }
    },
    "GeometryNodeUVUnwrap": {
      "GeometryNodeUVUnwrap": {
        "inputs": [
          "0: Selection [Bool]",
          "1: Seam [Bool]",
          "2: Margin [Float]",
          "3: Fill Holes [Bool]"
        ],
        "outputs": [
          "0: UV [Vector]"
        ],
        "description": "Generate a UV map based on seam edges"
      }
    },
    "GeometryNodeVertexOfCorner": {
      "GeometryNodeVertexOfCorner": {
        "inputs": [
          "0: Corner Index [Int]"
        ],
        "outputs": [
          "0: Vertex Index [Int]"
        ],
        "description": "Retrieve the vertex each face corner is attached to"
      }
    },
    "GeometryNodeViewer": {
      "GeometryNodeViewer": {
        "inputs": [
          "0: Geometry [Geometry]",
          "1: Value [Float]"
        ],
        "outputs": [],
        "description": "Display the input data in the Spreadsheet Editor"
      }
    },
    "GeometryNodeViewportTransform": {
      "GeometryNodeViewportTransform": {
        "inputs": [],
        "outputs": [
          "0: Projection [Matrix]",
          "1: View [Matrix]",
          "2: Is Orthographic [Bool]"
        ],
        "description": "Retrieve the view direction and location of the 3D viewport"
      }
    },
    "GeometryNodeVolumeCube": {
      "GeometryNodeVolumeCube": {
        "inputs": [
          "0: Density [Float]",
          "1: Background [Float]",
          "2: Min [Vector]",
          "3: Max [Vector]",
          "4: Resolution X [Int]",
          "5: Resolution Y [Int]",
          "6: Resolution Z [Int]"
        ],
        "outputs": [
          "0: Volume [Geometry]"
        ],
        "description": "Generate a dense volume with a field that controls the density at each grid voxel based on its position"
      }
    },
    "GeometryNodeVolumeToMesh": {
      "GeometryNodeVolumeToMesh": {
        "inputs": [
          "0: Volume [Geometry]",
          "1: Voxel Size [FloatDistance]",
          "2: Voxel Amount [Float]",
          "3: Threshold [Float]",
          "4: Adaptivity [FloatFactor]"
        ],
        "outputs": [
          "0: Mesh [Geometry]"
        ],
        "description": "Generate a mesh on the \"surface\" of a volume"
      }
    },
    "FunctionNodeAlignEulerToVector": {
      "FunctionNodeAlignEulerToVector": {
        "inputs": [
          "0: Rotation [VectorEuler]",
          "1: Factor [FloatFactor]",
          "2: Vector [Vector]"
        ],
        "outputs": [
          "0: Rotation [VectorEuler]"
        ],
        "description": ""
      }
    },
    "FunctionNodeAlignRotationToVector": {
      "FunctionNodeAlignRotationToVector": {
        "inputs": [
          "0: Rotation [Rotation]",
          "1: Factor [FloatFactor]",
          "2: Vector [VectorXYZ]"
        ],
        "outputs": [
          "0: Rotation [Rotation]"
        ],
        "description": ""
      }
    },
    "FunctionNodeAxesToRotation": {
      "FunctionNodeAxesToRotation": {
        "inputs": [
          "0: Primary Axis [Vector]",
          "1: Secondary Axis [Vector]"
        ],
        "outputs": [
          "0: Rotation [Rotation]"
        ],
        "description": "Create a rotation from a primary and (ideally orthogonal) secondary axis"
      }
    },
    "FunctionNodeAxisAngleToRotation": {
      "FunctionNodeAxisAngleToRotation": {
        "inputs": [
          "0: Axis [Vector]",
          "1: Angle [FloatAngle]"
        ],
        "outputs": [
          "0: Rotation [Rotation]"
        ],
        "description": ""
      }
    },
    "FunctionNodeBooleanMath": {
      "FunctionNodeBooleanMath": {
        "inputs": [
          "0: Boolean [Bool]",
          "1: Boolean [Bool]"
        ],
        "outputs": [
          "0: Boolean [Bool]"
        ],
        "description": ""
      }
    },
    "FunctionNodeCombineColor": {
      "FunctionNodeCombineColor": {
        "inputs": [
          "0: Red [FloatFactor]",
          "1: Green [FloatFactor]",
          "2: Blue [FloatFactor]",
          "3: Alpha [FloatFactor]"
        ],
        "outputs": [
          "0: Color [Color]"
        ],
        "description": ""
      }
    },
    "FunctionNodeCombineMatrix": {
      "FunctionNodeCombineMatrix": {
        "inputs": [
          "0: Column 1 Row 1 [Float]",
          "1: Column 1 Row 2 [Float]",
          "2: Column 1 Row 3 [Float]",
          "3: Column 1 Row 4 [Float]",
          "4: Column 2 Row 1 [Float]",
          "5: Column 2 Row 2 [Float]",
          "6: Column 2 Row 3 [Float]",
          "7: Column 2 Row 4 [Float]",
          "8: Column 3 Row 1 [Float]",
          "9: Column 3 Row 2 [Float]",
          "10: Column 3 Row 3 [Float]",
          "11: Column 3 Row 4 [Float]",
          "12: Column 4 Row 1 [Float]",
          "13: Column 4 Row 2 [Float]",
          "14: Column 4 Row 3 [Float]",
          "15: Column 4 Row 4 [Float]"
        ],
        "outputs": [
          "0: Matrix [Matrix]"
        ],
        "description": "Construct a 4x4 matrix from its individual values"
      }
    },
    "FunctionNodeCombineTransform": {
      "FunctionNodeCombineTransform": {
        "inputs": [
          "0: Translation [VectorTranslation]",
          "1: Rotation [Rotation]",
          "2: Scale [VectorXYZ]"
        ],
        "outputs": [
          "0: Transform [Matrix]"
        ],
        "description": ""
      }
    },
    "FunctionNodeCompare": {
      "FunctionNodeCompare": {
        "inputs": [
          "0: A [Float]",
          "1: B [Float]",
          "2: A [Int]",
          "3: B [Int]",
          "4: A [Vector]",
          "5: B [Vector]",
          "6: A [Color]",
          "7: B [Color]",
          "8: A [String]",
          "9: B [String]",
          "10: C [Float]",
          "11: Angle [FloatAngle]",
          "12: Epsilon [Float]"
        ],
        "outputs": [
          "0: Result [Bool]"
        ],
        "description": ""
      }
    },
    "FunctionNodeEulerToRotation": {
      "FunctionNodeEulerToRotation": {
        "inputs": [
          "0: Euler [VectorEuler]"
        ],
        "outputs": [
          "0: Rotation [Rotation]"
        ],
        "description": ""
      }
    },
    "FunctionNodeFindInString": {
      "FunctionNodeFindInString": {
        "inputs": [
          "0: String [String]",
          "1: Search [String]"
        ],
        "outputs": [
          "0: First Found [Int]",
          "1: Count [Int]"
        ],
        "description": ""
      }
    },
    "FunctionNodeFloatToInt": {
      "FunctionNodeFloatToInt": {
        "inputs": [
          "0: Float [Float]"
        ],
        "outputs": [
          "0: Integer [Int]"
        ],
        "description": ""
      }
    },
    "FunctionNodeHashValue": {
      "FunctionNodeHashValue": {
        "inputs": [
          "0: Value [Int]",
          "1: Seed [Int]"
        ],
        "outputs": [
          "0: Hash [Int]"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputBool": {
      "FunctionNodeInputBool": {
        "inputs": [],
        "outputs": [
          "0: Boolean [Bool]"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputColor": {
      "FunctionNodeInputColor": {
        "inputs": [],
        "outputs": [
          "0: Color [Color]"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputInt": {
      "FunctionNodeInputInt": {
        "inputs": [],
        "outputs": [
          "0: Integer [Int]"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputRotation": {
      "FunctionNodeInputRotation": {
        "inputs": [],
        "outputs": [
          "0: Rotation [Rotation]"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputSpecialCharacters": {
      "FunctionNodeInputSpecialCharacters": {
        "inputs": [],
        "outputs": [
          "0: Line Break [String]",
          "1: Tab [String]"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputString": {
      "FunctionNodeInputString": {
        "inputs": [],
        "outputs": [
          "0: String [String]"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputVector": {
      "FunctionNodeInputVector": {
        "inputs": [],
        "outputs": [
          "0: Vector [Vector]"
        ],
        "description": ""
      }
    },
    "FunctionNodeIntegerMath": {
      "FunctionNodeIntegerMath": {
        "inputs": [
          "0: Value [Int]",
          "1: Value [Int]",
          "2: Value [Int]"
        ],
        "outputs": [
          "0: Value [Int]"
        ],
        "description": ""
      }
    },
    "FunctionNodeInvertMatrix": {
      "FunctionNodeInvertMatrix": {
        "inputs": [
          "0: Matrix [Matrix]"
        ],
        "outputs": [
          "0: Matrix [Matrix]",
          "1: Invertible [Bool]"
        ],
        "description": ""
      }
    },
    "FunctionNodeInvertRotation": {
      "FunctionNodeInvertRotation": {
        "inputs": [
          "0: Rotation [Rotation]"
        ],
        "outputs": [
          "0: Rotation [Rotation]"
        ],
        "description": ""
      }
    },
    "FunctionNodeMatrixDeterminant": {
      "FunctionNodeMatrixDeterminant": {
        "inputs": [
          "0: Matrix [Matrix]"
        ],
        "outputs": [
          "0: Determinant [Float]"
        ],
        "description": ""
      }
    },
    "FunctionNodeMatrixMultiply": {
      "FunctionNodeMatrixMultiply": {
        "inputs": [
          "0: Matrix [Matrix]",
          "1: Matrix [Matrix]"
        ],
        "outputs": [
          "0: Matrix [Matrix]"
        ],
        "description": ""
      }
    },
    "FunctionNodeProjectPoint": {
      "FunctionNodeProjectPoint": {
        "inputs": [
          "0: Vector [VectorXYZ]",
          "1: Transform [Matrix]"
        ],
        "outputs": [
          "0: Vector [VectorXYZ]"
        ],
        "description": "Project a point using a matrix, using location, rotation, scale, and perspective divide"
      }
    },
    "FunctionNodeQuaternionToRotation": {
      "FunctionNodeQuaternionToRotation": {
        "inputs": [
          "0: W [Float]",
          "1: X [Float]",
          "2: Y [Float]",
          "3: Z [Float]"
        ],
        "outputs": [
          "0: Rotation [Rotation]"
        ],
        "description": ""
      }
    },
    "FunctionNodeRandomValue": {
      "FunctionNodeRandomValue": {
        "inputs": [
          "0: Min [Vector]",
          "1: Max [Vector]",
          "2: Min [Float]",
          "3: Max [Float]",
          "4: Min [Int]",
          "5: Max [Int]",
          "6: Probability [FloatFactor]",
          "7: ID [Int]",
          "8: Seed [Int]"
        ],
        "outputs": [
          "0: Value [Vector]",
          "1: Value [Float]",
          "2: Value [Int]",
          "3: Value [Bool]"
        ],
        "description": ""
      }
    },
    "FunctionNodeReplaceString": {
      "FunctionNodeReplaceString": {
        "inputs": [
          "0: String [String]",
          "1: Find [String]",
          "2: Replace [String]"
        ],
        "outputs": [
          "0: String [String]"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotateEuler": {
      "FunctionNodeRotateEuler": {
        "inputs": [
          "0: Rotation [VectorEuler]",
          "1: Rotate By [VectorEuler]",
          "2: Axis [VectorXYZ]",
          "3: Angle [FloatAngle]"
        ],
        "outputs": [
          "0: Rotation [Vector]"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotateRotation": {
      "FunctionNodeRotateRotation": {
        "inputs": [
          "0: Rotation [Rotation]",
          "1: Rotate By [Rotation]"
        ],
        "outputs": [
          "0: Rotation [Rotation]"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotateVector": {
      "FunctionNodeRotateVector": {
        "inputs": [
          "0: Vector [Vector]",
          "1: Rotation [Rotation]"
        ],
        "outputs": [
          "0: Vector [Vector]"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotationToAxisAngle": {
      "FunctionNodeRotationToAxisAngle": {
        "inputs": [
          "0: Rotation [Rotation]"
        ],
        "outputs": [
          "0: Axis [Vector]",
          "1: Angle [FloatAngle]"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotationToEuler": {
      "FunctionNodeRotationToEuler": {
        "inputs": [
          "0: Rotation [Rotation]"
        ],
        "outputs": [
          "0: Euler [VectorEuler]"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotationToQuaternion": {
      "FunctionNodeRotationToQuaternion": {
        "inputs": [
          "0: Rotation [Rotation]"
        ],
        "outputs": [
          "0: W [Float]",
          "1: X [Float]",
          "2: Y [Float]",
          "3: Z [Float]"
        ],
        "description": ""
      }
    },
    "FunctionNodeSeparateColor": {
      "FunctionNodeSeparateColor": {
        "inputs": [
          "0: Color [Color]"
        ],
        "outputs": [
          "0: Red [Float]",
          "1: Green [Float]",
          "2: Blue [Float]",
          "3: Alpha [Float]"
        ],
        "description": ""
      }
    },
    "FunctionNodeSeparateMatrix": {
      "FunctionNodeSeparateMatrix": {
        "inputs": [
          "0: Matrix [Matrix]"
        ],
        "outputs": [
          "0: Column 1 Row 1 [Float]",
          "1: Column 1 Row 2 [Float]",
          "2: Column 1 Row 3 [Float]",
          "3: Column 1 Row 4 [Float]",
          "4: Column 2 Row 1 [Float]",
          "5: Column 2 Row 2 [Float]",
          "6: Column 2 Row 3 [Float]",
          "7: Column 2 Row 4 [Float]",
          "8: Column 3 Row 1 [Float]",
          "9: Column 3 Row 2 [Float]",
          "10: Column 3 Row 3 [Float]",
          "11: Column 3 Row 4 [Float]",
          "12: Column 4 Row 1 [Float]",
          "13: Column 4 Row 2 [Float]",
          "14: Column 4 Row 3 [Float]",
          "15: Column 4 Row 4 [Float]"
        ],
        "description": "Split a 4x4 matrix into its individual values"
      }
    },
    "FunctionNodeSeparateTransform": {
      "FunctionNodeSeparateTransform": {
        "inputs": [
          "0: Transform [Matrix]"
        ],
        "outputs": [
          "0: Translation [VectorTranslation]",
          "1: Rotation [Rotation]",
          "2: Scale [VectorXYZ]"
        ],
        "description": ""
      }
    },
    "FunctionNodeSliceString": {
      "FunctionNodeSliceString": {
        "inputs": [
          "0: String [String]",
          "1: Position [Int]",
          "2: Length [Int]"
        ],
        "outputs": [
          "0: String [String]"
        ],
        "description": ""
      }
    },
    "FunctionNodeStringLength": {
      "FunctionNodeStringLength": {
        "inputs": [
          "0: String [String]"
        ],
        "outputs": [
          "0: Length [Int]"
        ],
        "description": ""
      }
    },
    "FunctionNodeTransformDirection": {
      "FunctionNodeTransformDirection": {
        "inputs": [
          "0: Direction [VectorXYZ]",
          "1: Transform [Matrix]"
        ],
        "outputs": [
          "0: Direction [VectorXYZ]"
        ],
        "description": ""
      }
    },
    "FunctionNodeTransformPoint": {
      "FunctionNodeTransformPoint": {
        "inputs": [
          "0: Vector [VectorXYZ]",
          "1: Transform [Matrix]"
        ],
        "outputs": [
          "0: Vector [VectorXYZ]"
        ],
        "description": ""
      }
    },
    "FunctionNodeTransposeMatrix": {
      "FunctionNodeTransposeMatrix": {
        "inputs": [
          "0: Matrix [Matrix]"
        ],
        "outputs": [
          "0: Matrix [Matrix]"
        ],
        "description": ""
      }
    },
    "FunctionNodeValueToString": {
      "FunctionNodeValueToString": {
        "inputs": [
          "0: Value [Float]",
          "1: Decimals [Int]"
        ],
        "outputs": [
          "0: String [String]"
        ],
        "description": ""
      }
    }
}