{
    "GeometryNodeAccumulateField": {
      "inputs": [
        "Value: Float",
        "Group ID: Int"
      ],
      "outputs": [
        "Leading: Float",
        "Trailing: Float",
        "Total: Float"
      ],
      "properties": [
        {
          "name": "data_type",
          "description": "Type of data that is accumulated",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "TRANSFORM"
          ]
        },
        {
          "name": "domain",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CORNER",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        }
      ],
      "description": "Add the values of an evaluated field together and output the running total for each element"
    },
    "GeometryNodeAttributeDomainSize": {
      "inputs": [
        "Geometry: Geometry"
      ],
      "outputs": [
        "Point Count: Int",
        "Edge Count: Int",
        "Face Count: Int",
        "Face Corner Count: Int",
        "Spline Count: Int",
        "Instance Count: Int",
        "Layer Count: Int"
      ],
      "properties": [
        {
          "name": "component",
          "type": "ENUM",
          "values": [
            "MESH",
            "POINTCLOUD",
            "CURVE",
            "INSTANCES",
            "GREASEPENCIL"
          ]
        }
      ],
      "description": "Retrieve the number of elements in a geometry for each attribute domain"
    },
    "GeometryNodeAttributeStatistic": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Attribute: Float"
      ],
      "outputs": [
        "Mean: Float",
        "Median: Float",
        "Sum: Float",
        "Min: Float",
        "Max: Float",
        "Range: Float",
        "Standard Deviation: Float",
        "Variance: Float"
      ],
      "properties": [
        {
          "name": "data_type",
          "description": "The data type the attribute is converted to before calculating the results",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        },
        {
          "name": "domain",
          "description": "Which domain to read the data from",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CORNER",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        }
      ],
      "description": "Calculate statistics about a data set from a field evaluated on a geometry"
    },
    "GeometryNodeBake": {
      "inputs": [
        "Geometry: Geometry",
        ": Virtual"
      ],
      "outputs": [
        "Geometry: Geometry",
        ": Virtual"
      ],
      "properties": [
        {
          "name": "bake_items",
          "type": "COLLECTION"
        },
        {
          "name": "active_index",
          "description": "Index of the active item",
          "type": "INT"
        },
        {
          "name": "active_item",
          "description": "Index of the active item",
          "type": "POINTER"
        }
      ],
      "description": "Cache the incoming data so that it can be used without recomputation"
    },
    "GeometryNodeBlurAttribute": {
      "inputs": [
        "Value: Float",
        "Iterations: Int",
        "Weight: FloatFactor"
      ],
      "outputs": [
        "Value: Float"
      ],
      "properties": [
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        }
      ],
      "description": "Mix attribute values of neighboring elements"
    },
    "GeometryNodeBoundBox": {
      "inputs": [
        "Geometry: Geometry"
      ],
      "outputs": [
        "Bounding Box: Geometry",
        "Min: Vector",
        "Max: Vector"
      ],
      "properties": [],
      "description": "Calculate the limits of a geometry's positions and generate a box mesh with those dimensions"
    },
    "GeometryNodeCaptureAttribute": {
      "inputs": [
        "Geometry: Geometry",
        ": Virtual"
      ],
      "outputs": [
        "Geometry: Geometry",
        ": Virtual"
      ],
      "properties": [
        {
          "name": "capture_items",
          "type": "COLLECTION"
        },
        {
          "name": "active_index",
          "description": "Index of the active item",
          "type": "INT"
        },
        {
          "name": "active_item",
          "description": "Index of the active item",
          "type": "POINTER"
        },
        {
          "name": "domain",
          "description": "Which domain to store the data in",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CORNER",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        }
      ],
      "description": "Store the result of a field on a geometry and output the data as a node socket. Allows remembering or interpolating data as the geometry changes, such as positions before deformation"
    },
    "GeometryNodeCollectionInfo": {
      "inputs": [
        "Collection: Collection",
        "Separate Children: Bool",
        "Reset Children: Bool"
      ],
      "outputs": [
        "Instances: Geometry"
      ],
      "properties": [
        {
          "name": "transform_space",
          "description": "The transformation of the instances output. Does not affect the internal geometry",
          "type": "ENUM",
          "values": [
            "ORIGINAL",
            "RELATIVE"
          ]
        }
      ],
      "description": "Retrieve geometry instances from a collection"
    },
    "GeometryNodeConvexHull": {
      "inputs": [
        "Geometry: Geometry"
      ],
      "outputs": [
        "Convex Hull: Geometry"
      ],
      "properties": [],
      "description": "Create a mesh that encloses all points in the input geometry with the smallest number of points"
    },
    "GeometryNodeCornersOfEdge": {
      "inputs": [
        "Edge Index: Int",
        "Weights: Float",
        "Sort Index: Int"
      ],
      "outputs": [
        "Corner Index: Int",
        "Total: Int"
      ],
      "properties": [],
      "description": "Retrieve face corners connected to edges"
    },
    "GeometryNodeCornersOfFace": {
      "inputs": [
        "Face Index: Int",
        "Weights: Float",
        "Sort Index: Int"
      ],
      "outputs": [
        "Corner Index: Int",
        "Total: Int"
      ],
      "properties": [],
      "description": "Retrieve corners that make up a face"
    },
    "GeometryNodeCornersOfVertex": {
      "inputs": [
        "Vertex Index: Int",
        "Weights: Float",
        "Sort Index: Int"
      ],
      "outputs": [
        "Corner Index: Int",
        "Total: Int"
      ],
      "properties": [],
      "description": "Retrieve face corners connected to vertices"
    },
    "GeometryNodeCurveArc": {
      "inputs": [
        "Resolution: IntUnsigned",
        "Start: VectorTranslation",
        "Middle: VectorTranslation",
        "End: VectorTranslation",
        "Radius: FloatDistance",
        "Start Angle: FloatAngle",
        "Sweep Angle: FloatAngle",
        "Offset Angle: FloatAngle",
        "Connect Center: Bool",
        "Invert Arc: Bool"
      ],
      "outputs": [
        "Curve: Geometry",
        "Center: Vector",
        "Normal: Vector",
        "Radius: Float"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Method used to determine radius and placement",
          "type": "ENUM",
          "values": [
            "POINTS",
            "RADIUS"
          ]
        }
      ],
      "description": "Generate a poly spline arc"
    },
    "GeometryNodeCurveEndpointSelection": {
      "inputs": [
        "Start Size: Int",
        "End Size: Int"
      ],
      "outputs": [
        "Selection: Bool"
      ],
      "properties": [],
      "description": "Provide a selection for an arbitrary number of endpoints in each spline"
    },
    "GeometryNodeCurveHandleTypeSelection": {
      "inputs": [],
      "outputs": [
        "Selection: Bool"
      ],
      "properties": [
        {
          "name": "handle_type",
          "type": "ENUM",
          "values": [
            "FREE",
            "AUTO",
            "VECTOR",
            "ALIGN"
          ]
        },
        {
          "name": "mode",
          "description": "Whether to check the type of left and right handles",
          "type": "ENUM",
          "values": [
            "LEFT",
            "RIGHT"
          ]
        }
      ],
      "description": "Provide a selection based on the handle types of B\u00e9zier control points"
    },
    "GeometryNodeCurveLength": {
      "inputs": [
        "Curve: Geometry"
      ],
      "outputs": [
        "Length: Float"
      ],
      "properties": [],
      "description": "Retrieve the length of all splines added together"
    },
    "GeometryNodeCurveOfPoint": {
      "inputs": [
        "Point Index: Int"
      ],
      "outputs": [
        "Curve Index: Int",
        "Index in Curve: Int"
      ],
      "properties": [],
      "description": "Retrieve the curve a control point is part of"
    },
    "GeometryNodeCurvePrimitiveBezierSegment": {
      "inputs": [
        "Resolution: IntUnsigned",
        "Start: VectorTranslation",
        "Start Handle: VectorTranslation",
        "End Handle: VectorTranslation",
        "End: VectorTranslation"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Method used to determine control handles",
          "type": "ENUM",
          "values": [
            "POSITION",
            "OFFSET"
          ]
        }
      ],
      "description": "Generate a 2D B\u00e9zier spline from the given control points and handles"
    },
    "GeometryNodeCurvePrimitiveCircle": {
      "inputs": [
        "Resolution: Int",
        "Point 1: VectorTranslation",
        "Point 2: VectorTranslation",
        "Point 3: VectorTranslation",
        "Radius: FloatDistance"
      ],
      "outputs": [
        "Curve: Geometry",
        "Center: Vector"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Method used to determine radius and placement",
          "type": "ENUM",
          "values": [
            "POINTS",
            "RADIUS"
          ]
        }
      ],
      "description": "Generate a poly spline circle"
    },
    "GeometryNodeCurvePrimitiveLine": {
      "inputs": [
        "Start: VectorTranslation",
        "End: VectorTranslation",
        "Direction: Vector",
        "Length: FloatDistance"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Method used to determine radius and placement",
          "type": "ENUM",
          "values": [
            "POINTS",
            "DIRECTION"
          ]
        }
      ],
      "description": "Generate a poly spline line with two points"
    },
    "GeometryNodeCurvePrimitiveQuadrilateral": {
      "inputs": [
        "Width: FloatDistance",
        "Height: FloatDistance",
        "Bottom Width: FloatDistance",
        "Top Width: FloatDistance",
        "Offset: FloatDistance",
        "Bottom Height: FloatDistance",
        "Top Height: FloatDistance",
        "Point 1: VectorTranslation",
        "Point 2: VectorTranslation",
        "Point 3: VectorTranslation",
        "Point 4: VectorTranslation"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "type": "ENUM",
          "values": [
            "RECTANGLE",
            "PARALLELOGRAM",
            "TRAPEZOID",
            "KITE",
            "POINTS"
          ]
        }
      ],
      "description": "Generate a polygon with four points"
    },
    "GeometryNodeCurveQuadraticBezier": {
      "inputs": [
        "Resolution: IntUnsigned",
        "Start: VectorTranslation",
        "Middle: VectorTranslation",
        "End: VectorTranslation"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [],
      "description": "Generate a poly spline in a parabola shape with control points positions"
    },
    "GeometryNodeCurveSetHandles": {
      "inputs": [
        "Curve: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [
        {
          "name": "handle_type",
          "type": "ENUM",
          "values": [
            "FREE",
            "AUTO",
            "VECTOR",
            "ALIGN"
          ]
        },
        {
          "name": "mode",
          "description": "Whether to update left and right handles",
          "type": "ENUM",
          "values": [
            "LEFT",
            "RIGHT"
          ]
        }
      ],
      "description": "Set the handle type for the control points of a B\u00e9zier curve"
    },
    "GeometryNodeCurveSpiral": {
      "inputs": [
        "Resolution: IntUnsigned",
        "Rotations: Float",
        "Start Radius: FloatDistance",
        "End Radius: FloatDistance",
        "Height: FloatDistance",
        "Reverse: Bool"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [],
      "description": "Generate a poly spline in a spiral shape"
    },
    "GeometryNodeCurveSplineType": {
      "inputs": [
        "Curve: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [
        {
          "name": "spline_type",
          "description": "The curve type to change the selected curves to",
          "type": "ENUM",
          "values": [
            "CATMULL_ROM",
            "POLY",
            "BEZIER",
            "NURBS"
          ]
        }
      ],
      "description": "Change the type of curves"
    },
    "GeometryNodeCurveStar": {
      "inputs": [
        "Points: IntUnsigned",
        "Inner Radius: FloatDistance",
        "Outer Radius: FloatDistance",
        "Twist: FloatAngle"
      ],
      "outputs": [
        "Curve: Geometry",
        "Outer Points: Bool"
      ],
      "properties": [],
      "description": "Generate a poly spline in a star pattern by connecting alternating points of two circles"
    },
    "GeometryNodeCurveToMesh": {
      "inputs": [
        "Curve: Geometry",
        "Profile Curve: Geometry",
        "Fill Caps: Bool"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [],
      "description": "Convert curves into a mesh, optionally with a custom profile shape defined by curves"
    },
    "GeometryNodeCurveToPoints": {
      "inputs": [
        "Curve: Geometry",
        "Count: Int",
        "Length: FloatDistance"
      ],
      "outputs": [
        "Points: Geometry",
        "Tangent: Vector",
        "Normal: Vector",
        "Rotation: Rotation"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "How to generate points from the input curve",
          "type": "ENUM",
          "values": [
            "EVALUATED",
            "COUNT",
            "LENGTH"
          ]
        }
      ],
      "description": "Generate a point cloud by sampling positions along curves"
    },
    "GeometryNodeCurvesToGreasePencil": {
      "inputs": [
        "Curves: Geometry",
        "Selection: Bool",
        "Instances as Layers: Bool"
      ],
      "outputs": [
        "Grease Pencil: Geometry"
      ],
      "properties": [],
      "description": "Convert the curves in each top-level instance into Grease Pencil layer"
    },
    "GeometryNodeDeformCurvesOnSurface": {
      "inputs": [
        "Curves: Geometry"
      ],
      "outputs": [
        "Curves: Geometry"
      ],
      "properties": [],
      "description": "Translate and rotate curves based on changes between the object's original and evaluated surface mesh"
    },
    "GeometryNodeDeleteGeometry": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Which parts of the mesh component to delete",
          "type": "ENUM",
          "values": [
            "ALL",
            "EDGE_FACE",
            "ONLY_FACE"
          ]
        },
        {
          "name": "domain",
          "description": "Which domain to delete in",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        }
      ],
      "description": "Remove selected elements of a geometry"
    },
    "GeometryNodeDistributePointsInGrid": {
      "inputs": [
        "Grid: Float",
        "Density: Float",
        "Seed: Int",
        "Spacing: VectorXYZ",
        "Threshold: Float"
      ],
      "outputs": [
        "Points: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Method to use for scattering points",
          "type": "ENUM",
          "values": [
            "DENSITY_RANDOM",
            "DENSITY_GRID"
          ]
        }
      ],
      "description": "Generate points inside a volume grid"
    },
    "GeometryNodeDistributePointsInVolume": {
      "inputs": [
        "Volume: Geometry",
        "Density: Float",
        "Seed: Int",
        "Spacing: VectorXYZ",
        "Threshold: Float"
      ],
      "outputs": [
        "Points: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Method to use for scattering points",
          "type": "ENUM",
          "values": [
            "DENSITY_RANDOM",
            "DENSITY_GRID"
          ]
        }
      ],
      "description": "Generate points inside a volume"
    },
    "GeometryNodeDistributePointsOnFaces": {
      "inputs": [
        "Mesh: Geometry",
        "Selection: Bool",
        "Distance Min: FloatDistance",
        "Density Max: Float",
        "Density: Float",
        "Density Factor: FloatFactor",
        "Seed: Int"
      ],
      "outputs": [
        "Points: Geometry",
        "Normal: Vector",
        "Rotation: Rotation"
      ],
      "properties": [
        {
          "name": "distribute_method",
          "description": "Method to use for scattering points",
          "type": "ENUM",
          "values": [
            "RANDOM",
            "POISSON"
          ]
        },
        {
          "name": "use_legacy_normal",
          "description": "Output the normal and rotation values that have been output before the node started taking smooth normals into account",
          "type": "BOOLEAN"
        }
      ],
      "description": "Generate points spread out on the surface of a mesh"
    },
    "GeometryNodeDualMesh": {
      "inputs": [
        "Mesh: Geometry",
        "Keep Boundaries: Bool"
      ],
      "outputs": [
        "Dual Mesh: Geometry"
      ],
      "properties": [],
      "description": "Convert Faces into vertices and vertices into faces"
    },
    "GeometryNodeDuplicateElements": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Amount: Int"
      ],
      "outputs": [
        "Geometry: Geometry",
        "Duplicate Index: Int"
      ],
      "properties": [
        {
          "name": "domain",
          "description": "Which domain to duplicate",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "SPLINE",
            "LAYER",
            "INSTANCE"
          ]
        }
      ],
      "description": "Generate an arbitrary number copies of each selected input element"
    },
    "GeometryNodeEdgePathsToCurves": {
      "inputs": [
        "Mesh: Geometry",
        "Start Vertices: Bool",
        "Next Vertex Index: Int"
      ],
      "outputs": [
        "Curves: Geometry"
      ],
      "properties": [],
      "description": "Output curves following paths across mesh edges"
    },
    "GeometryNodeEdgePathsToSelection": {
      "inputs": [
        "Start Vertices: Bool",
        "Next Vertex Index: Int"
      ],
      "outputs": [
        "Selection: Bool"
      ],
      "properties": [],
      "description": "Output a selection of edges by following paths across mesh edges"
    },
    "GeometryNodeEdgesOfCorner": {
      "inputs": [
        "Corner Index: Int"
      ],
      "outputs": [
        "Next Edge Index: Int",
        "Previous Edge Index: Int"
      ],
      "properties": [],
      "description": "Retrieve the edges on both sides of a face corner"
    },
    "GeometryNodeEdgesOfVertex": {
      "inputs": [
        "Vertex Index: Int",
        "Weights: Float",
        "Sort Index: Int"
      ],
      "outputs": [
        "Edge Index: Int",
        "Total: Int"
      ],
      "properties": [],
      "description": "Retrieve the edges connected to each vertex"
    },
    "GeometryNodeEdgesToFaceGroups": {
      "inputs": [
        "Boundary Edges: Bool"
      ],
      "outputs": [
        "Face Group ID: Int"
      ],
      "properties": [],
      "description": "Group faces into regions surrounded by the selected boundary edges"
    },
    "GeometryNodeExtrudeMesh": {
      "inputs": [
        "Mesh: Geometry",
        "Selection: Bool",
        "Offset: VectorTranslation",
        "Offset Scale: Float",
        "Individual: Bool"
      ],
      "outputs": [
        "Mesh: Geometry",
        "Top: Bool",
        "Side: Bool"
      ],
      "properties": [
        {
          "name": "mode",
          "type": "ENUM",
          "values": [
            "VERTICES",
            "EDGES",
            "FACES"
          ]
        }
      ],
      "description": "Generate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary"
    },
    "GeometryNodeFaceOfCorner": {
      "inputs": [
        "Corner Index: Int"
      ],
      "outputs": [
        "Face Index: Int",
        "Index in Face: Int"
      ],
      "properties": [],
      "description": "Retrieve the face each face corner is part of"
    },
    "GeometryNodeFieldAtIndex": {
      "inputs": [
        "Index: Int",
        "Value: Float"
      ],
      "outputs": [
        "Value: Float"
      ],
      "properties": [
        {
          "name": "domain",
          "description": "Domain the field is evaluated in",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CORNER",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        },
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        }
      ],
      "description": "Retrieve data of other elements in the context's geometry"
    },
    "GeometryNodeFieldOnDomain": {
      "inputs": [
        "Value: Float"
      ],
      "outputs": [
        "Value: Float"
      ],
      "properties": [
        {
          "name": "domain",
          "description": "Domain the field is evaluated in",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CORNER",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        },
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        }
      ],
      "description": "Retrieve values from a field on a different domain besides the domain from the context"
    },
    "GeometryNodeFillCurve": {
      "inputs": [
        "Curve: Geometry",
        "Group ID: Int"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "type": "ENUM",
          "values": [
            "TRIANGLES",
            "NGONS"
          ]
        }
      ],
      "description": "Generate a mesh on the XY plane with faces on the inside of input curves"
    },
    "GeometryNodeFilletCurve": {
      "inputs": [
        "Curve: Geometry",
        "Count: Int",
        "Radius: FloatDistance",
        "Limit Radius: Bool"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "How to choose number of vertices on fillet",
          "type": "ENUM",
          "values": [
            "BEZIER",
            "POLY"
          ]
        }
      ],
      "description": "Round corners by generating circular arcs on each control point"
    },
    "GeometryNodeFlipFaces": {
      "inputs": [
        "Mesh: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [],
      "description": "Reverse the order of the vertices and edges of selected faces, flipping their normal direction"
    },
    "GeometryNodeForeachGeometryElementInput": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        ": Virtual"
      ],
      "outputs": [
        "Index: Int",
        "Element: Geometry",
        ": Virtual"
      ],
      "properties": [
        {
          "name": "paired_output",
          "description": "Zone output node that this input node is paired with",
          "type": "POINTER"
        }
      ],
      "description": ""
    },
    "GeometryNodeForeachGeometryElementOutput": {
      "inputs": [
        ": Virtual",
        "Geometry: Geometry",
        ": Virtual"
      ],
      "outputs": [
        "Geometry: Geometry",
        ": Virtual",
        "Geometry: Geometry",
        ": Virtual"
      ],
      "properties": [
        {
          "name": "input_items",
          "type": "COLLECTION"
        },
        {
          "name": "main_items",
          "type": "COLLECTION"
        },
        {
          "name": "generation_items",
          "type": "COLLECTION"
        },
        {
          "name": "active_input_index",
          "description": "Index of the active item",
          "type": "INT"
        },
        {
          "name": "active_generation_index",
          "description": "Index of the active item",
          "type": "INT"
        },
        {
          "name": "active_main_index",
          "description": "Index of the active item",
          "type": "INT"
        },
        {
          "name": "domain",
          "description": "Geometry domain that is iterated over",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CORNER",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        },
        {
          "name": "inspection_index",
          "description": "Iteration index that is used by inspection features like the viewer node or socket inspection",
          "type": "INT"
        }
      ],
      "description": ""
    },
    "GeometryNodeGeometryToInstance": {
      "inputs": [
        "Geometry: Geometry"
      ],
      "outputs": [
        "Instances: Geometry"
      ],
      "properties": [],
      "description": "Convert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large"
    },
    "GeometryNodeGetNamedGrid": {
      "inputs": [
        "Volume: Geometry",
        "Name: String",
        "Remove: Bool"
      ],
      "outputs": [
        "Volume: Geometry",
        "Grid: Float"
      ],
      "properties": [
        {
          "name": "data_type",
          "description": "Type of grid data",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "BOOLEAN",
            "VECTOR",
            "ROTATION",
            "MATRIX",
            "STRING",
            "MENU",
            "RGBA",
            "OBJECT",
            "IMAGE",
            "GEOMETRY",
            "COLLECTION",
            "TEXTURE",
            "MATERIAL"
          ]
        }
      ],
      "description": "Get volume grid from a volume geometry with the specified name"
    },
    "GeometryNodeGizmoDial": {
      "inputs": [
        "Value: Float",
        "Position: VectorTranslation",
        "Up: VectorXYZ",
        "Screen Space: Bool",
        "Radius: Float"
      ],
      "outputs": [
        "Transform: Geometry"
      ],
      "properties": [
        {
          "name": "color_id",
          "type": "ENUM",
          "values": [
            "PRIMARY",
            "SECONDARY",
            "X",
            "Y",
            "Z"
          ]
        }
      ],
      "description": "Show a dial gizmo in the viewport for a value"
    },
    "GeometryNodeGizmoLinear": {
      "inputs": [
        "Value: Float",
        "Position: VectorTranslation",
        "Direction: VectorXYZ"
      ],
      "outputs": [
        "Transform: Geometry"
      ],
      "properties": [
        {
          "name": "color_id",
          "type": "ENUM",
          "values": [
            "PRIMARY",
            "SECONDARY",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "draw_style",
          "type": "ENUM",
          "values": [
            "ARROW",
            "CROSS",
            "BOX"
          ]
        }
      ],
      "description": "Show a linear gizmo in the viewport for a value"
    },
    "GeometryNodeGizmoTransform": {
      "inputs": [
        "Value: Matrix",
        "Position: VectorTranslation",
        "Rotation: Rotation"
      ],
      "outputs": [
        "Transform: Geometry"
      ],
      "properties": [
        {
          "name": "use_translation_x",
          "type": "BOOLEAN"
        },
        {
          "name": "use_translation_y",
          "type": "BOOLEAN"
        },
        {
          "name": "use_translation_z",
          "type": "BOOLEAN"
        },
        {
          "name": "use_rotation_x",
          "type": "BOOLEAN"
        },
        {
          "name": "use_rotation_y",
          "type": "BOOLEAN"
        },
        {
          "name": "use_rotation_z",
          "type": "BOOLEAN"
        },
        {
          "name": "use_scale_x",
          "type": "BOOLEAN"
        },
        {
          "name": "use_scale_y",
          "type": "BOOLEAN"
        },
        {
          "name": "use_scale_z",
          "type": "BOOLEAN"
        }
      ],
      "description": "Show a transform gizmo in the viewport"
    },
    "GeometryNodeGreasePencilToCurves": {
      "inputs": [
        "Grease Pencil: Geometry",
        "Selection: Bool",
        "Layers as Instances: Bool"
      ],
      "outputs": [
        "Curves: Geometry"
      ],
      "properties": [],
      "description": "Convert Grease Pencil layers into curve instances"
    },
    "GeometryNodeGridToMesh": {
      "inputs": [
        "Grid: Float",
        "Threshold: Float",
        "Adaptivity: FloatFactor"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [],
      "description": "Generate a mesh on the \"surface\" of a volume grid"
    },
    "GeometryNodeGroup": {
      "inputs": [],
      "outputs": [],
      "properties": [
        {
          "name": "node_tree",
          "type": "POINTER"
        }
      ],
      "description": ""
    },
    "GeometryNodeImageInfo": {
      "inputs": [
        "Image: Image",
        "Frame: Int"
      ],
      "outputs": [
        "Width: Int",
        "Height: Int",
        "Has Alpha: Bool",
        "Frame Count: Int",
        "FPS: Float"
      ],
      "properties": [],
      "description": "Retrieve information about an image"
    },
    "GeometryNodeImageTexture": {
      "inputs": [
        "Image: Image",
        "Vector: Vector",
        "Frame: Int"
      ],
      "outputs": [
        "Color: Color",
        "Alpha: Float"
      ],
      "properties": [
        {
          "name": "interpolation",
          "description": "Method for smoothing values between pixels",
          "type": "ENUM",
          "values": [
            "Linear",
            "Closest",
            "Cubic"
          ]
        },
        {
          "name": "extension",
          "description": "How the image is extrapolated past its original bounds",
          "type": "ENUM",
          "values": [
            "REPEAT",
            "EXTEND",
            "CLIP",
            "MIRROR"
          ]
        }
      ],
      "description": "Sample values from an image texture"
    },
    "GeometryNodeImportOBJ": {
      "inputs": [
        "Path: StringFilePath"
      ],
      "outputs": [
        "Instances: Geometry"
      ],
      "properties": [],
      "description": "Import geometry from an OBJ file"
    },
    "GeometryNodeImportPLY": {
      "inputs": [
        "Path: StringFilePath"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [],
      "description": "Import a point cloud from a PLY file"
    },
    "GeometryNodeImportSTL": {
      "inputs": [
        "Path: StringFilePath"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [],
      "description": "Import a mesh from an STL file"
    },
    "GeometryNodeIndexOfNearest": {
      "inputs": [
        "Position: Vector",
        "Group ID: Int"
      ],
      "outputs": [
        "Index: Int",
        "Has Neighbor: Bool"
      ],
      "properties": [],
      "description": "Find the nearest element in a group. Similar to the \"Sample Nearest\" node"
    },
    "GeometryNodeIndexSwitch": {
      "inputs": [
        "Index: Int",
        "0: Geometry",
        "1: Geometry",
        ": Virtual"
      ],
      "outputs": [
        "Output: Geometry"
      ],
      "properties": [
        {
          "name": "index_switch_items",
          "type": "COLLECTION"
        },
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "BOOLEAN",
            "VECTOR",
            "ROTATION",
            "MATRIX",
            "STRING",
            "MENU",
            "RGBA",
            "OBJECT",
            "IMAGE",
            "GEOMETRY",
            "COLLECTION",
            "TEXTURE",
            "MATERIAL"
          ]
        }
      ],
      "description": "Choose between an arbitrary number of values with an index"
    },
    "GeometryNodeInputActiveCamera": {
      "inputs": [],
      "outputs": [
        "Active Camera: Object"
      ],
      "properties": [],
      "description": "Retrieve the scene's active camera"
    },
    "GeometryNodeInputCollection": {
      "inputs": [],
      "outputs": [
        "Collection: Collection"
      ],
      "properties": [
        {
          "name": "collection",
          "type": "POINTER"
        }
      ],
      "description": "Output a single collection"
    },
    "GeometryNodeInputCurveHandlePositions": {
      "inputs": [
        "Relative: Bool"
      ],
      "outputs": [
        "Left: Vector",
        "Right: Vector"
      ],
      "properties": [],
      "description": "Retrieve the position of each B\u00e9zier control point's handles"
    },
    "GeometryNodeInputCurveTilt": {
      "inputs": [],
      "outputs": [
        "Tilt: Float"
      ],
      "properties": [],
      "description": "Retrieve the angle at each control point used to twist the curve's normal around its tangent"
    },
    "GeometryNodeInputEdgeSmooth": {
      "inputs": [],
      "outputs": [
        "Smooth: Bool"
      ],
      "properties": [],
      "description": "Retrieve whether each edge is marked for smooth or split normals"
    },
    "GeometryNodeInputID": {
      "inputs": [],
      "outputs": [
        "ID: Int"
      ],
      "properties": [],
      "description": "Retrieve a stable random identifier value from the \"id\" attribute on the point domain, or the index if the attribute does not exist"
    },
    "GeometryNodeInputImage": {
      "inputs": [],
      "outputs": [
        "Image: Image"
      ],
      "properties": [
        {
          "name": "image",
          "type": "POINTER"
        }
      ],
      "description": "Input an image data-block"
    },
    "GeometryNodeInputIndex": {
      "inputs": [],
      "outputs": [
        "Index: Int"
      ],
      "properties": [],
      "description": "Retrieve an integer value indicating the position of each element in the list, starting at zero"
    },
    "GeometryNodeInputInstanceRotation": {
      "inputs": [],
      "outputs": [
        "Rotation: Rotation"
      ],
      "properties": [],
      "description": "Retrieve the rotation of each instance in the geometry"
    },
    "GeometryNodeInputInstanceScale": {
      "inputs": [],
      "outputs": [
        "Scale: Vector"
      ],
      "properties": [],
      "description": "Retrieve the scale of each instance in the geometry"
    },
    "GeometryNodeInputMaterial": {
      "inputs": [],
      "outputs": [
        "Material: Material"
      ],
      "properties": [
        {
          "name": "material",
          "type": "POINTER"
        }
      ],
      "description": "Output a single material"
    },
    "GeometryNodeInputMaterialIndex": {
      "inputs": [],
      "outputs": [
        "Material Index: Int"
      ],
      "properties": [],
      "description": "Retrieve the index of the material used for each element in the geometry's list of materials"
    },
    "GeometryNodeInputMeshEdgeAngle": {
      "inputs": [],
      "outputs": [
        "Unsigned Angle: Float",
        "Signed Angle: Float"
      ],
      "properties": [],
      "description": "The angle between the normals of connected manifold faces"
    },
    "GeometryNodeInputMeshEdgeNeighbors": {
      "inputs": [],
      "outputs": [
        "Face Count: Int"
      ],
      "properties": [],
      "description": "Retrieve the number of faces that use each edge as one of their sides"
    },
    "GeometryNodeInputMeshEdgeVertices": {
      "inputs": [],
      "outputs": [
        "Vertex Index 1: Int",
        "Vertex Index 2: Int",
        "Position 1: Vector",
        "Position 2: Vector"
      ],
      "properties": [],
      "description": "Retrieve topology information relating to each edge of a mesh"
    },
    "GeometryNodeInputMeshFaceArea": {
      "inputs": [],
      "outputs": [
        "Area: Float"
      ],
      "properties": [],
      "description": "Calculate the surface area of a mesh's faces"
    },
    "GeometryNodeInputMeshFaceIsPlanar": {
      "inputs": [
        "Threshold: FloatDistance"
      ],
      "outputs": [
        "Planar: Bool"
      ],
      "properties": [],
      "description": "Retrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal"
    },
    "GeometryNodeInputMeshFaceNeighbors": {
      "inputs": [],
      "outputs": [
        "Vertex Count: Int",
        "Face Count: Int"
      ],
      "properties": [],
      "description": "Retrieve topology information relating to each face of a mesh"
    },
    "GeometryNodeInputMeshIsland": {
      "inputs": [],
      "outputs": [
        "Island Index: Int",
        "Island Count: Int"
      ],
      "properties": [],
      "description": "Retrieve information about separate connected regions in a mesh"
    },
    "GeometryNodeInputMeshVertexNeighbors": {
      "inputs": [],
      "outputs": [
        "Vertex Count: Int",
        "Face Count: Int"
      ],
      "properties": [],
      "description": "Retrieve topology information relating to each vertex of a mesh"
    },
    "GeometryNodeInputNamedAttribute": {
      "inputs": [
        "Name: String"
      ],
      "outputs": [
        "Attribute: Float",
        "Exists: Bool"
      ],
      "properties": [
        {
          "name": "data_type",
          "description": "The data type used to read the attribute values",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        }
      ],
      "description": "Retrieve the data of a specified attribute"
    },
    "GeometryNodeInputNamedLayerSelection": {
      "inputs": [
        "Name: String"
      ],
      "outputs": [
        "Selection: Bool"
      ],
      "properties": [],
      "description": "Output a selection of a Grease Pencil layer"
    },
    "GeometryNodeInputNormal": {
      "inputs": [],
      "outputs": [
        "Normal: Vector"
      ],
      "properties": [
        {
          "name": "legacy_corner_normals",
          "description": "Always use face normals for the face corner domain, matching old behavior of the node",
          "type": "BOOLEAN"
        }
      ],
      "description": "Retrieve a unit length vector indicating the direction pointing away from the geometry at each element"
    },
    "GeometryNodeInputObject": {
      "inputs": [],
      "outputs": [
        "Object: Object"
      ],
      "properties": [
        {
          "name": "object",
          "type": "POINTER"
        }
      ],
      "description": "Output a single object"
    },
    "GeometryNodeInputPosition": {
      "inputs": [],
      "outputs": [
        "Position: Vector"
      ],
      "properties": [],
      "description": "Retrieve a vector indicating the location of each element"
    },
    "GeometryNodeInputRadius": {
      "inputs": [],
      "outputs": [
        "Radius: Float"
      ],
      "properties": [],
      "description": "Retrieve the radius at each point on curve or point cloud geometry"
    },
    "GeometryNodeInputSceneTime": {
      "inputs": [],
      "outputs": [
        "Seconds: Float",
        "Frame: Float"
      ],
      "properties": [],
      "description": "Retrieve the current time in the scene's animation in units of seconds or frames"
    },
    "GeometryNodeInputShadeSmooth": {
      "inputs": [],
      "outputs": [
        "Smooth: Bool"
      ],
      "properties": [],
      "description": "Retrieve whether each face is marked for smooth or sharp normals"
    },
    "GeometryNodeInputShortestEdgePaths": {
      "inputs": [
        "End Vertex: Bool",
        "Edge Cost: Float"
      ],
      "outputs": [
        "Next Vertex Index: Int",
        "Total Cost: Float"
      ],
      "properties": [],
      "description": "Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge"
    },
    "GeometryNodeInputSplineCyclic": {
      "inputs": [],
      "outputs": [
        "Cyclic: Bool"
      ],
      "properties": [],
      "description": "Retrieve whether each spline endpoint connects to the beginning"
    },
    "GeometryNodeInputSplineResolution": {
      "inputs": [],
      "outputs": [
        "Resolution: Int"
      ],
      "properties": [],
      "description": "Retrieve the number of evaluated points that will be generated for every control point on curves"
    },
    "GeometryNodeInputTangent": {
      "inputs": [],
      "outputs": [
        "Tangent: Vector"
      ],
      "properties": [],
      "description": "Retrieve the direction of curves at each control point"
    },
    "GeometryNodeInstanceOnPoints": {
      "inputs": [
        "Points: Geometry",
        "Selection: Bool",
        "Instance: Geometry",
        "Pick Instance: Bool",
        "Instance Index: Int",
        "Rotation: Rotation",
        "Scale: VectorXYZ"
      ],
      "outputs": [
        "Instances: Geometry"
      ],
      "properties": [],
      "description": "Generate a reference to geometry at each of the input points, without duplicating its underlying data"
    },
    "GeometryNodeInstanceTransform": {
      "inputs": [],
      "outputs": [
        "Transform: Matrix"
      ],
      "properties": [],
      "description": "Retrieve the full transformation of each instance in the geometry"
    },
    "GeometryNodeInstancesToPoints": {
      "inputs": [
        "Instances: Geometry",
        "Selection: Bool",
        "Position: Vector",
        "Radius: FloatDistance"
      ],
      "outputs": [
        "Points: Geometry"
      ],
      "properties": [],
      "description": "Generate points at the origins of instances.\nNote: Nested instances are not affected by this node"
    },
    "GeometryNodeInterpolateCurves": {
      "inputs": [
        "Guide Curves: Geometry",
        "Guide Up: Vector",
        "Guide Group ID: Int",
        "Points: Geometry",
        "Point Up: Vector",
        "Point Group ID: Int",
        "Max Neighbors: Int"
      ],
      "outputs": [
        "Curves: Geometry",
        "Closest Index: Int",
        "Closest Weight: Float"
      ],
      "properties": [],
      "description": "Generate new curves on points by interpolating between existing curves"
    },
    "GeometryNodeIsViewport": {
      "inputs": [],
      "outputs": [
        "Is Viewport: Bool"
      ],
      "properties": [],
      "description": "Retrieve whether the nodes are being evaluated for the viewport rather than the final render"
    },
    "GeometryNodeJoinGeometry": {
      "inputs": [
        "Geometry: Geometry"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [],
      "description": "Merge separately generated geometries into a single one"
    },
    "GeometryNodeMaterialSelection": {
      "inputs": [
        "Material: Material"
      ],
      "outputs": [
        "Selection: Bool"
      ],
      "properties": [],
      "description": "Provide a selection of faces that use the specified material"
    },
    "GeometryNodeMenuSwitch": {
      "inputs": [
        "Menu: Menu",
        "A: Geometry",
        "B: Geometry",
        ": Virtual"
      ],
      "outputs": [
        "Output: Geometry"
      ],
      "properties": [
        {
          "name": "enum_items",
          "type": "COLLECTION"
        },
        {
          "name": "active_index",
          "description": "Index of the active item",
          "type": "INT"
        },
        {
          "name": "active_item",
          "description": "Active item",
          "type": "POINTER"
        },
        {
          "name": "enum_definition",
          "description": "The enum definition can now be accessed directly on the node. This exists for backward compatibility.",
          "type": "POINTER"
        },
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "BOOLEAN",
            "VECTOR",
            "ROTATION",
            "MATRIX",
            "STRING",
            "MENU",
            "RGBA",
            "OBJECT",
            "IMAGE",
            "GEOMETRY",
            "COLLECTION",
            "TEXTURE",
            "MATERIAL"
          ]
        }
      ],
      "description": "Select from multiple inputs by name"
    },
    "GeometryNodeMergeByDistance": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Distance: FloatDistance"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "type": "ENUM",
          "values": [
            "ALL",
            "CONNECTED"
          ]
        }
      ],
      "description": "Merge vertices or points within a given distance"
    },
    "GeometryNodeMergeLayers": {
      "inputs": [
        "Grease Pencil: Geometry",
        "Selection: Bool",
        "Group ID: Int"
      ],
      "outputs": [
        "Grease Pencil: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Determines how to choose which layers are merged",
          "type": "ENUM",
          "values": [
            "MERGE_BY_NAME",
            "MERGE_BY_ID"
          ]
        }
      ],
      "description": "Join groups of Grease Pencil layers into one"
    },
    "GeometryNodeMeshBoolean": {
      "inputs": [
        "Mesh 1: Geometry",
        "Mesh 2: Geometry",
        "Self Intersection: Bool",
        "Hole Tolerant: Bool"
      ],
      "outputs": [
        "Mesh: Geometry",
        "Intersecting Edges: Bool"
      ],
      "properties": [
        {
          "name": "operation",
          "type": "ENUM",
          "values": [
            "INTERSECT",
            "UNION",
            "DIFFERENCE"
          ]
        },
        {
          "name": "solver",
          "type": "ENUM",
          "values": [
            "EXACT",
            "FLOAT"
          ]
        }
      ],
      "description": "Cut, subtract, or join multiple mesh inputs"
    },
    "GeometryNodeMeshCircle": {
      "inputs": [
        "Vertices: Int",
        "Radius: FloatDistance"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [
        {
          "name": "fill_type",
          "type": "ENUM",
          "values": [
            "NONE",
            "NGON",
            "TRIANGLE_FAN"
          ]
        }
      ],
      "description": "Generate a circular ring of edges"
    },
    "GeometryNodeMeshCone": {
      "inputs": [
        "Vertices: Int",
        "Side Segments: Int",
        "Fill Segments: Int",
        "Radius Top: FloatDistance",
        "Radius Bottom: FloatDistance",
        "Depth: FloatDistance"
      ],
      "outputs": [
        "Mesh: Geometry",
        "Top: Bool",
        "Bottom: Bool",
        "Side: Bool",
        "UV Map: Vector"
      ],
      "properties": [
        {
          "name": "fill_type",
          "type": "ENUM",
          "values": [
            "NONE",
            "NGON",
            "TRIANGLE_FAN"
          ]
        }
      ],
      "description": "Generate a cone mesh"
    },
    "GeometryNodeMeshCube": {
      "inputs": [
        "Size: VectorTranslation",
        "Vertices X: Int",
        "Vertices Y: Int",
        "Vertices Z: Int"
      ],
      "outputs": [
        "Mesh: Geometry",
        "UV Map: Vector"
      ],
      "properties": [],
      "description": "Generate a cuboid mesh with variable side lengths and subdivisions"
    },
    "GeometryNodeMeshCylinder": {
      "inputs": [
        "Vertices: Int",
        "Side Segments: Int",
        "Fill Segments: Int",
        "Radius: FloatDistance",
        "Depth: FloatDistance"
      ],
      "outputs": [
        "Mesh: Geometry",
        "Top: Bool",
        "Side: Bool",
        "Bottom: Bool",
        "UV Map: Vector"
      ],
      "properties": [
        {
          "name": "fill_type",
          "type": "ENUM",
          "values": [
            "NONE",
            "NGON",
            "TRIANGLE_FAN"
          ]
        }
      ],
      "description": "Generate a cylinder mesh"
    },
    "GeometryNodeMeshFaceSetBoundaries": {
      "inputs": [
        "Face Group ID: Int"
      ],
      "outputs": [
        "Boundary Edges: Bool"
      ],
      "properties": [],
      "description": "Find edges on the boundaries between groups of faces with the same ID value"
    },
    "GeometryNodeMeshGrid": {
      "inputs": [
        "Size X: FloatDistance",
        "Size Y: FloatDistance",
        "Vertices X: Int",
        "Vertices Y: Int"
      ],
      "outputs": [
        "Mesh: Geometry",
        "UV Map: Vector"
      ],
      "properties": [],
      "description": "Generate a planar mesh on the XY plane"
    },
    "GeometryNodeMeshIcoSphere": {
      "inputs": [
        "Radius: FloatDistance",
        "Subdivisions: Int"
      ],
      "outputs": [
        "Mesh: Geometry",
        "UV Map: Vector"
      ],
      "properties": [],
      "description": "Generate a spherical mesh that consists of equally sized triangles"
    },
    "GeometryNodeMeshLine": {
      "inputs": [
        "Count: Int",
        "Resolution: FloatDistance",
        "Start Location: VectorTranslation",
        "Offset: VectorTranslation"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "type": "ENUM",
          "values": [
            "OFFSET",
            "END_POINTS"
          ]
        },
        {
          "name": "count_mode",
          "type": "ENUM",
          "values": [
            "TOTAL",
            "RESOLUTION"
          ]
        }
      ],
      "description": "Generate vertices in a line and connect them with edges"
    },
    "GeometryNodeMeshToCurve": {
      "inputs": [
        "Mesh: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [],
      "description": "Generate a curve from a mesh"
    },
    "GeometryNodeMeshToDensityGrid": {
      "inputs": [
        "Mesh: Geometry",
        "Density: Float",
        "Voxel Size: FloatDistance",
        "Gradient Width: FloatDistance"
      ],
      "outputs": [
        "Density Grid: Float"
      ],
      "properties": [],
      "description": "Create a filled volume grid from a mesh"
    },
    "GeometryNodeMeshToPoints": {
      "inputs": [
        "Mesh: Geometry",
        "Selection: Bool",
        "Position: Vector",
        "Radius: FloatDistance"
      ],
      "outputs": [
        "Points: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "type": "ENUM",
          "values": [
            "VERTICES",
            "EDGES",
            "FACES",
            "CORNERS"
          ]
        }
      ],
      "description": "Generate a point cloud from a mesh's vertices"
    },
    "GeometryNodeMeshToSDFGrid": {
      "inputs": [
        "Mesh: Geometry",
        "Voxel Size: FloatDistance",
        "Band Width: Int"
      ],
      "outputs": [
        "SDF Grid: Float"
      ],
      "properties": [],
      "description": "Create a signed distance volume grid from a mesh"
    },
    "GeometryNodeMeshToVolume": {
      "inputs": [
        "Mesh: Geometry",
        "Density: Float",
        "Voxel Size: FloatDistance",
        "Voxel Amount: Float",
        "Interior Band Width: FloatDistance"
      ],
      "outputs": [
        "Volume: Geometry"
      ],
      "properties": [
        {
          "name": "resolution_mode",
          "description": "How the voxel size is specified",
          "type": "ENUM",
          "values": [
            "VOXEL_AMOUNT",
            "VOXEL_SIZE"
          ]
        }
      ],
      "description": "Create a fog volume with the shape of the input mesh's surface"
    },
    "GeometryNodeMeshUVSphere": {
      "inputs": [
        "Segments: Int",
        "Rings: Int",
        "Radius: FloatDistance"
      ],
      "outputs": [
        "Mesh: Geometry",
        "UV Map: Vector"
      ],
      "properties": [],
      "description": "Generate a spherical mesh with quads, except for triangles at the top and bottom"
    },
    "GeometryNodeObjectInfo": {
      "inputs": [
        "Object: Object",
        "As Instance: Bool"
      ],
      "outputs": [
        "Transform: Matrix",
        "Location: Vector",
        "Rotation: Rotation",
        "Scale: Vector",
        "Geometry: Geometry"
      ],
      "properties": [
        {
          "name": "transform_space",
          "description": "The transformation of the vector and geometry outputs",
          "type": "ENUM",
          "values": [
            "ORIGINAL",
            "RELATIVE"
          ]
        }
      ],
      "description": "Retrieve information from an object"
    },
    "GeometryNodeOffsetCornerInFace": {
      "inputs": [
        "Corner Index: Int",
        "Offset: Int"
      ],
      "outputs": [
        "Corner Index: Int"
      ],
      "properties": [],
      "description": "Retrieve corners in the same face as another"
    },
    "GeometryNodeOffsetPointInCurve": {
      "inputs": [
        "Point Index: Int",
        "Offset: Int"
      ],
      "outputs": [
        "Is Valid Offset: Bool",
        "Point Index: Int"
      ],
      "properties": [],
      "description": "Offset a control point index within its curve"
    },
    "GeometryNodePoints": {
      "inputs": [
        "Count: Int",
        "Position: VectorTranslation",
        "Radius: FloatDistance"
      ],
      "outputs": [
        "Points: Geometry"
      ],
      "properties": [],
      "description": "Generate a point cloud with positions and radii defined by fields"
    },
    "GeometryNodePointsOfCurve": {
      "inputs": [
        "Curve Index: Int",
        "Weights: Float",
        "Sort Index: Int"
      ],
      "outputs": [
        "Point Index: Int",
        "Total: Int"
      ],
      "properties": [],
      "description": "Retrieve a point index within a curve"
    },
    "GeometryNodePointsToCurves": {
      "inputs": [
        "Points: Geometry",
        "Curve Group ID: Int",
        "Weight: Float"
      ],
      "outputs": [
        "Curves: Geometry"
      ],
      "properties": [],
      "description": "Split all points to curve by its group ID and reorder by weight"
    },
    "GeometryNodePointsToSDFGrid": {
      "inputs": [
        "Points: Geometry",
        "Radius: FloatDistance",
        "Voxel Size: FloatDistance"
      ],
      "outputs": [
        "SDF Grid: Float"
      ],
      "properties": [],
      "description": "Create a signed distance volume grid from points"
    },
    "GeometryNodePointsToVertices": {
      "inputs": [
        "Points: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [],
      "description": "Generate a mesh vertex for each point cloud point"
    },
    "GeometryNodePointsToVolume": {
      "inputs": [
        "Points: Geometry",
        "Density: Float",
        "Voxel Size: FloatDistance",
        "Voxel Amount: Float",
        "Radius: FloatDistance"
      ],
      "outputs": [
        "Volume: Geometry"
      ],
      "properties": [
        {
          "name": "resolution_mode",
          "description": "How the voxel size is specified",
          "type": "ENUM",
          "values": [
            "VOXEL_AMOUNT",
            "VOXEL_SIZE"
          ]
        }
      ],
      "description": "Generate a fog volume sphere around every point"
    },
    "GeometryNodeProximity": {
      "inputs": [
        "Geometry: Geometry",
        "Group ID: Int",
        "Sample Position: Vector",
        "Sample Group ID: Int"
      ],
      "outputs": [
        "Position: Vector",
        "Distance: Float",
        "Is Valid: Bool"
      ],
      "properties": [
        {
          "name": "target_element",
          "description": "Element of the target geometry to calculate the distance from",
          "type": "ENUM",
          "values": [
            "POINTS",
            "EDGES",
            "FACES"
          ]
        }
      ],
      "description": "Compute the closest location on the target geometry"
    },
    "GeometryNodeRaycast": {
      "inputs": [
        "Target Geometry: Geometry",
        "Attribute: Float",
        "Source Position: Vector",
        "Ray Direction: Vector",
        "Ray Length: FloatDistance"
      ],
      "outputs": [
        "Is Hit: Bool",
        "Hit Position: Vector",
        "Hit Normal: Vector",
        "Hit Distance: Float",
        "Attribute: Float"
      ],
      "properties": [
        {
          "name": "mapping",
          "description": "Mapping from the target geometry to hit points",
          "type": "ENUM",
          "values": [
            "INTERPOLATED",
            "NEAREST"
          ]
        },
        {
          "name": "data_type",
          "description": "Type of data stored in attribute",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        }
      ],
      "description": "Cast rays from the context geometry onto a target geometry, and retrieve information from each hit point"
    },
    "GeometryNodeRealizeInstances": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Realize All: Bool",
        "Depth: Int"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [],
      "description": "Convert instances into real geometry data"
    },
    "GeometryNodeRemoveAttribute": {
      "inputs": [
        "Geometry: Geometry",
        "Name: String"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [
        {
          "name": "pattern_mode",
          "description": "How the attributes to remove are chosen",
          "type": "ENUM",
          "values": [
            "EXACT",
            "WILDCARD"
          ]
        }
      ],
      "description": "Delete an attribute with a specified name from a geometry. Typically used to optimize performance"
    },
    "GeometryNodeRepeatInput": {
      "inputs": [
        "Iterations: Int",
        ": Virtual"
      ],
      "outputs": [
        "Iteration: Int",
        ": Virtual"
      ],
      "properties": [
        {
          "name": "paired_output",
          "description": "Zone output node that this input node is paired with",
          "type": "POINTER"
        }
      ],
      "description": ""
    },
    "GeometryNodeRepeatOutput": {
      "inputs": [
        "Geometry: Geometry",
        ": Virtual"
      ],
      "outputs": [
        "Geometry: Geometry",
        ": Virtual"
      ],
      "properties": [
        {
          "name": "repeat_items",
          "type": "COLLECTION"
        },
        {
          "name": "active_index",
          "description": "Index of the active item",
          "type": "INT"
        },
        {
          "name": "active_item",
          "description": "Index of the active item",
          "type": "POINTER"
        },
        {
          "name": "inspection_index",
          "description": "Iteration index that is used by inspection features like the viewer node or socket inspection",
          "type": "INT"
        }
      ],
      "description": ""
    },
    "GeometryNodeReplaceMaterial": {
      "inputs": [
        "Geometry: Geometry",
        "Old: Material",
        "New: Material"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [],
      "description": "Swap one material with another"
    },
    "GeometryNodeResampleCurve": {
      "inputs": [
        "Curve: Geometry",
        "Selection: Bool",
        "Count: Int",
        "Length: FloatDistance"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "How to specify the amount of samples",
          "type": "ENUM",
          "values": [
            "EVALUATED",
            "COUNT",
            "LENGTH"
          ]
        },
        {
          "name": "keep_last_segment",
          "description": "Don't collapse a curves to single points if they are shorter than the given length. The collapsing behavior exists for compatibility reasons.",
          "type": "BOOLEAN"
        }
      ],
      "description": "Generate a poly spline for each input spline"
    },
    "GeometryNodeReverseCurve": {
      "inputs": [
        "Curve: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [],
      "description": "Change the direction of curves by swapping their start and end data"
    },
    "GeometryNodeRotateInstances": {
      "inputs": [
        "Instances: Geometry",
        "Selection: Bool",
        "Rotation: Rotation",
        "Pivot Point: VectorTranslation",
        "Local Space: Bool"
      ],
      "outputs": [
        "Instances: Geometry"
      ],
      "properties": [],
      "description": "Rotate geometry instances in local or global space"
    },
    "GeometryNodeSDFGridBoolean": {
      "inputs": [
        "Grid 1: Float",
        "Grid 2: Float"
      ],
      "outputs": [
        "Grid: Float"
      ],
      "properties": [
        {
          "name": "operation",
          "type": "ENUM",
          "values": [
            "INTERSECT",
            "UNION",
            "DIFFERENCE"
          ]
        }
      ],
      "description": "Cut, subtract, or join multiple SDF volume grid inputs"
    },
    "GeometryNodeSampleCurve": {
      "inputs": [
        "Curves: Geometry",
        "Value: Float",
        "Factor: FloatFactor",
        "Length: FloatDistance",
        "Curve Index: Int"
      ],
      "outputs": [
        "Value: Float",
        "Position: Vector",
        "Tangent: Vector",
        "Normal: Vector"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Method for sampling input",
          "type": "ENUM",
          "values": [
            "FACTOR",
            "LENGTH"
          ]
        },
        {
          "name": "use_all_curves",
          "description": "Sample lengths based on the total length of all curves, rather than using a length inside each selected curve",
          "type": "BOOLEAN"
        },
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        }
      ],
      "description": "Retrieve data from a point on a curve at a certain distance from its start"
    },
    "GeometryNodeSampleGrid": {
      "inputs": [
        "Grid: Float",
        "Position: Vector"
      ],
      "outputs": [
        "Value: Float"
      ],
      "properties": [
        {
          "name": "data_type",
          "description": "Node socket data type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "BOOLEAN",
            "VECTOR",
            "ROTATION",
            "MATRIX",
            "STRING",
            "MENU",
            "RGBA",
            "OBJECT",
            "IMAGE",
            "GEOMETRY",
            "COLLECTION",
            "TEXTURE",
            "MATERIAL"
          ]
        },
        {
          "name": "interpolation_mode",
          "description": "How to interpolate the values between neighboring voxels",
          "type": "ENUM",
          "values": [
            "NEAREST",
            "TRILINEAR",
            "TRIQUADRATIC"
          ]
        }
      ],
      "description": ""
    },
    "GeometryNodeSampleGridIndex": {
      "inputs": [
        "Grid: Float",
        "X: Int",
        "Y: Int",
        "Z: Int"
      ],
      "outputs": [
        "Value: Float"
      ],
      "properties": [
        {
          "name": "data_type",
          "description": "Node socket data type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "BOOLEAN",
            "VECTOR",
            "ROTATION",
            "MATRIX",
            "STRING",
            "MENU",
            "RGBA",
            "OBJECT",
            "IMAGE",
            "GEOMETRY",
            "COLLECTION",
            "TEXTURE",
            "MATERIAL"
          ]
        }
      ],
      "description": "Retrieve volume grid values at specific voxels"
    },
    "GeometryNodeSampleIndex": {
      "inputs": [
        "Geometry: Geometry",
        "Value: Float",
        "Index: Int"
      ],
      "outputs": [
        "Value: Float"
      ],
      "properties": [
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        },
        {
          "name": "domain",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CORNER",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        },
        {
          "name": "clamp",
          "description": "Clamp the indices to the size of the attribute domain instead of outputting a default value for invalid indices",
          "type": "BOOLEAN"
        }
      ],
      "description": "Retrieve values from specific geometry elements"
    },
    "GeometryNodeSampleNearest": {
      "inputs": [
        "Geometry: Geometry",
        "Sample Position: Vector"
      ],
      "outputs": [
        "Index: Int"
      ],
      "properties": [
        {
          "name": "domain",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CORNER"
          ]
        }
      ],
      "description": "Find the element of a geometry closest to a position. Similar to the \"Index of Nearest\" node"
    },
    "GeometryNodeSampleNearestSurface": {
      "inputs": [
        "Mesh: Geometry",
        "Value: Float",
        "Group ID: Int",
        "Sample Position: Vector",
        "Sample Group ID: Int"
      ],
      "outputs": [
        "Value: Float",
        "Is Valid: Bool"
      ],
      "properties": [
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        }
      ],
      "description": "Calculate the interpolated value of a mesh attribute on the closest point of its surface"
    },
    "GeometryNodeSampleUVSurface": {
      "inputs": [
        "Mesh: Geometry",
        "Value: Float",
        "UV Map: Vector",
        "Sample UV: Vector"
      ],
      "outputs": [
        "Value: Float",
        "Is Valid: Bool"
      ],
      "properties": [
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        }
      ],
      "description": "Calculate the interpolated values of a mesh attribute at a UV coordinate"
    },
    "GeometryNodeScaleElements": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Scale: Float",
        "Center: VectorTranslation",
        "Axis: Vector"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [
        {
          "name": "domain",
          "description": "Element type to transform",
          "type": "ENUM",
          "values": [
            "FACE",
            "EDGE"
          ]
        },
        {
          "name": "scale_mode",
          "type": "ENUM",
          "values": [
            "UNIFORM",
            "SINGLE_AXIS"
          ]
        }
      ],
      "description": "Scale groups of connected edges and faces"
    },
    "GeometryNodeScaleInstances": {
      "inputs": [
        "Instances: Geometry",
        "Selection: Bool",
        "Scale: VectorXYZ",
        "Center: VectorTranslation",
        "Local Space: Bool"
      ],
      "outputs": [
        "Instances: Geometry"
      ],
      "properties": [],
      "description": "Scale geometry instances in local or global space"
    },
    "GeometryNodeSelfObject": {
      "inputs": [],
      "outputs": [
        "Self Object: Object"
      ],
      "properties": [],
      "description": "Retrieve the object that contains the geometry nodes modifier currently being executed"
    },
    "GeometryNodeSeparateComponents": {
      "inputs": [
        "Geometry: Geometry"
      ],
      "outputs": [
        "Mesh: Geometry",
        "Curve: Geometry",
        "Grease Pencil: Geometry",
        "Point Cloud: Geometry",
        "Volume: Geometry",
        "Instances: Geometry"
      ],
      "properties": [],
      "description": "Split a geometry into a separate output for each type of data in the geometry"
    },
    "GeometryNodeSeparateGeometry": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Selection: Geometry",
        "Inverted: Geometry"
      ],
      "properties": [
        {
          "name": "domain",
          "description": "Which domain to separate on",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        }
      ],
      "description": "Split a geometry into two geometry outputs based on a selection"
    },
    "GeometryNodeSetCurveHandlePositions": {
      "inputs": [
        "Curve: Geometry",
        "Selection: Bool",
        "Position: Vector",
        "Offset: Vector"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Whether to update left and right handles",
          "type": "ENUM",
          "values": [
            "LEFT",
            "RIGHT"
          ]
        }
      ],
      "description": "Set the positions for the handles of B\u00e9zier curves"
    },
    "GeometryNodeSetCurveNormal": {
      "inputs": [
        "Curve: Geometry",
        "Selection: Bool",
        "Normal: VectorXYZ"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Mode for curve normal evaluation",
          "type": "ENUM",
          "values": [
            "MINIMUM_TWIST",
            "Z_UP",
            "FREE"
          ]
        }
      ],
      "description": "Set the evaluation mode for curve normals"
    },
    "GeometryNodeSetCurveRadius": {
      "inputs": [
        "Curve: Geometry",
        "Selection: Bool",
        "Radius: FloatDistance"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [],
      "description": "Set the radius of the curve at each control point"
    },
    "GeometryNodeSetCurveTilt": {
      "inputs": [
        "Curve: Geometry",
        "Selection: Bool",
        "Tilt: FloatAngle"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [],
      "description": "Set the tilt angle at each curve control point"
    },
    "GeometryNodeSetGeometryName": {
      "inputs": [
        "Geometry: Geometry",
        "Name: String"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [],
      "description": "Set the name of a geometry for easier debugging"
    },
    "GeometryNodeSetID": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "ID: Int"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [],
      "description": "Set the id attribute on the input geometry, mainly used internally for randomizing"
    },
    "GeometryNodeSetInstanceTransform": {
      "inputs": [
        "Instances: Geometry",
        "Selection: Bool",
        "Transform: Matrix"
      ],
      "outputs": [
        "Instances: Geometry"
      ],
      "properties": [],
      "description": "Set the transformation matrix of every instance"
    },
    "GeometryNodeSetMaterial": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Material: Material"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [],
      "description": "Assign a material to geometry elements"
    },
    "GeometryNodeSetMaterialIndex": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Material Index: Int"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [],
      "description": "Set the material index for each selected geometry element"
    },
    "GeometryNodeSetPointRadius": {
      "inputs": [
        "Points: Geometry",
        "Selection: Bool",
        "Radius: FloatDistance"
      ],
      "outputs": [
        "Points: Geometry"
      ],
      "properties": [],
      "description": "Set the display size of point cloud points"
    },
    "GeometryNodeSetPosition": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Position: Vector",
        "Offset: VectorTranslation"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [],
      "description": "Set the location of each point"
    },
    "GeometryNodeSetShadeSmooth": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Shade Smooth: Bool"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [
        {
          "name": "domain",
          "type": "ENUM",
          "values": [
            "EDGE",
            "FACE"
          ]
        }
      ],
      "description": "Control the smoothness of mesh normals around each face by changing the \"shade smooth\" attribute"
    },
    "GeometryNodeSetSplineCyclic": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Cyclic: Bool"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [],
      "description": "Control whether each spline loops back on itself by changing the \"cyclic\" attribute"
    },
    "GeometryNodeSetSplineResolution": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Resolution: Int"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [],
      "description": "Control how many evaluated points should be generated on every curve segment"
    },
    "GeometryNodeSimulationInput": {
      "inputs": [],
      "outputs": [
        "Delta Time: Float"
      ],
      "properties": [
        {
          "name": "paired_output",
          "description": "Zone output node that this input node is paired with",
          "type": "POINTER"
        }
      ],
      "description": "Input data for the simulation zone"
    },
    "GeometryNodeSimulationOutput": {
      "inputs": [
        "Skip: Bool",
        "Geometry: Geometry",
        ": Virtual"
      ],
      "outputs": [
        "Geometry: Geometry",
        ": Virtual"
      ],
      "properties": [
        {
          "name": "state_items",
          "type": "COLLECTION"
        },
        {
          "name": "active_index",
          "description": "Index of the active item",
          "type": "INT"
        },
        {
          "name": "active_item",
          "description": "Index of the active item",
          "type": "POINTER"
        }
      ],
      "description": "Output data from the simulation zone"
    },
    "GeometryNodeSortElements": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Group ID: Int",
        "Sort Weight: Float"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [
        {
          "name": "domain",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CURVE",
            "INSTANCE"
          ]
        }
      ],
      "description": "Rearrange geometry elements, changing their indices"
    },
    "GeometryNodeSplineLength": {
      "inputs": [],
      "outputs": [
        "Length: Float",
        "Point Count: Int"
      ],
      "properties": [],
      "description": "Retrieve the total length of each spline, as a distance or as a number of points"
    },
    "GeometryNodeSplineParameter": {
      "inputs": [],
      "outputs": [
        "Factor: Float",
        "Length: Float",
        "Index: Int"
      ],
      "properties": [],
      "description": "Retrieve how far along each spline a control point is"
    },
    "GeometryNodeSplitEdges": {
      "inputs": [
        "Mesh: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [],
      "description": "Duplicate mesh edges and break connections with the surrounding faces"
    },
    "GeometryNodeSplitToInstances": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Group ID: Int"
      ],
      "outputs": [
        "Instances: Geometry",
        "Group ID: Int"
      ],
      "properties": [
        {
          "name": "domain",
          "description": "Attribute domain for the Selection and Group ID inputs",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        }
      ],
      "description": "Create separate geometries containing the elements from the same group"
    },
    "GeometryNodeStoreNamedAttribute": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool",
        "Name: String",
        "Value: Float"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [
        {
          "name": "data_type",
          "description": "Type of data stored in attribute",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        },
        {
          "name": "domain",
          "description": "Which domain to store the data in",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CORNER",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        }
      ],
      "description": "Store the result of a field on a geometry as an attribute with the specified name"
    },
    "GeometryNodeStoreNamedGrid": {
      "inputs": [
        "Volume: Geometry",
        "Name: String",
        "Grid: Float"
      ],
      "outputs": [
        "Volume: Geometry"
      ],
      "properties": [
        {
          "name": "data_type",
          "description": "Type of grid data",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        }
      ],
      "description": "Store grid data in a volume geometry with the specified name"
    },
    "GeometryNodeStringJoin": {
      "inputs": [
        "Delimiter: String",
        "Strings: String"
      ],
      "outputs": [
        "String: String"
      ],
      "properties": [],
      "description": "Combine any number of input strings"
    },
    "GeometryNodeStringToCurves": {
      "inputs": [
        "String: String",
        "Size: FloatDistance",
        "Character Spacing: Float",
        "Word Spacing: Float",
        "Line Spacing: Float",
        "Text Box Width: FloatDistance",
        "Text Box Height: FloatDistance"
      ],
      "outputs": [
        "Curve Instances: Geometry",
        "Remainder: String",
        "Line: Int",
        "Pivot Point: Vector"
      ],
      "properties": [
        {
          "name": "font",
          "description": "Font of the text. Falls back to the UI font by default.",
          "type": "POINTER"
        },
        {
          "name": "overflow",
          "description": "Handle the text behavior when it doesn't fit in the text boxes",
          "type": "ENUM",
          "values": [
            "OVERFLOW",
            "SCALE_TO_FIT",
            "TRUNCATE"
          ]
        },
        {
          "name": "align_x",
          "description": "Text horizontal alignment from the object or text box center",
          "type": "ENUM",
          "values": [
            "LEFT",
            "CENTER",
            "RIGHT",
            "JUSTIFY",
            "FLUSH"
          ]
        },
        {
          "name": "align_y",
          "description": "Text vertical alignment from the object center",
          "type": "ENUM",
          "values": [
            "TOP",
            "TOP_BASELINE",
            "MIDDLE",
            "BOTTOM_BASELINE",
            "BOTTOM"
          ]
        },
        {
          "name": "pivot_mode",
          "description": "Pivot point position relative to character",
          "type": "ENUM",
          "values": [
            "MIDPOINT",
            "TOP_LEFT",
            "TOP_CENTER",
            "TOP_RIGHT",
            "BOTTOM_LEFT",
            "BOTTOM_CENTER",
            "BOTTOM_RIGHT"
          ]
        }
      ],
      "description": "Generate a paragraph of text with a specific font, using a curve instance to store each character"
    },
    "GeometryNodeSubdivideCurve": {
      "inputs": [
        "Curve: Geometry",
        "Cuts: Int"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [],
      "description": "Dividing each curve segment into a specified number of pieces"
    },
    "GeometryNodeSubdivideMesh": {
      "inputs": [
        "Mesh: Geometry",
        "Level: Int"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [],
      "description": "Divide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices"
    },
    "GeometryNodeSubdivisionSurface": {
      "inputs": [
        "Mesh: Geometry",
        "Level: Int",
        "Edge Crease: FloatFactor",
        "Vertex Crease: FloatFactor",
        "Limit Surface: Bool"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [
        {
          "name": "uv_smooth",
          "description": "Controls how smoothing is applied to UVs",
          "type": "ENUM",
          "values": [
            "NONE",
            "PRESERVE_CORNERS",
            "PRESERVE_CORNERS_AND_JUNCTIONS",
            "PRESERVE_CORNERS_JUNCTIONS_AND_CONCAVE",
            "PRESERVE_BOUNDARIES",
            "SMOOTH_ALL"
          ]
        },
        {
          "name": "boundary_smooth",
          "description": "Controls how open boundaries are smoothed",
          "type": "ENUM",
          "values": [
            "PRESERVE_CORNERS",
            "ALL"
          ]
        }
      ],
      "description": "Divide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method"
    },
    "GeometryNodeSwitch": {
      "inputs": [
        "Switch: Bool",
        "False: Geometry",
        "True: Geometry"
      ],
      "outputs": [
        "Output: Geometry"
      ],
      "properties": [
        {
          "name": "input_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "BOOLEAN",
            "VECTOR",
            "ROTATION",
            "MATRIX",
            "STRING",
            "MENU",
            "RGBA",
            "OBJECT",
            "IMAGE",
            "GEOMETRY",
            "COLLECTION",
            "TEXTURE",
            "MATERIAL"
          ]
        }
      ],
      "description": "Switch between two inputs"
    },
    "GeometryNodeTool3DCursor": {
      "inputs": [],
      "outputs": [
        "Location: VectorTranslation",
        "Rotation: Rotation"
      ],
      "properties": [],
      "description": "The scene's 3D cursor location and rotation"
    },
    "GeometryNodeToolActiveElement": {
      "inputs": [],
      "outputs": [
        "Index: Int",
        "Exists: Bool"
      ],
      "properties": [
        {
          "name": "domain",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE"
          ]
        }
      ],
      "description": "Active element indices of the edited geometry, for tool execution"
    },
    "GeometryNodeToolFaceSet": {
      "inputs": [],
      "outputs": [
        "Face Set: Int",
        "Exists: Bool"
      ],
      "properties": [],
      "description": "Each face's sculpt face set value"
    },
    "GeometryNodeToolMousePosition": {
      "inputs": [],
      "outputs": [
        "Mouse X: Int",
        "Mouse Y: Int",
        "Region Width: Int",
        "Region Height: Int"
      ],
      "properties": [],
      "description": "Retrieve the position of the mouse cursor"
    },
    "GeometryNodeToolSelection": {
      "inputs": [],
      "outputs": [
        "Boolean: Bool",
        "Float: Float"
      ],
      "properties": [],
      "description": "User selection of the edited geometry, for tool execution"
    },
    "GeometryNodeToolSetFaceSet": {
      "inputs": [
        "Mesh: Geometry",
        "Selection: Bool",
        "Face Set: Int"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [],
      "description": "Set sculpt face set values for faces"
    },
    "GeometryNodeToolSetSelection": {
      "inputs": [
        "Geometry: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [
        {
          "name": "domain",
          "type": "ENUM",
          "values": [
            "POINT",
            "EDGE",
            "FACE",
            "CURVE"
          ]
        },
        {
          "name": "selection_type",
          "type": "ENUM",
          "values": [
            "BOOLEAN",
            "FLOAT"
          ]
        }
      ],
      "description": "Set selection of the edited geometry, for tool execution"
    },
    "GeometryNodeTransform": {
      "inputs": [
        "Geometry: Geometry",
        "Translation: VectorTranslation",
        "Rotation: Rotation",
        "Scale: VectorXYZ",
        "Transform: Matrix"
      ],
      "outputs": [
        "Geometry: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "How the transformation is specified",
          "type": "ENUM",
          "values": [
            "COMPONENTS",
            "MATRIX"
          ]
        }
      ],
      "description": "Translate, rotate or scale the geometry"
    },
    "GeometryNodeTranslateInstances": {
      "inputs": [
        "Instances: Geometry",
        "Selection: Bool",
        "Translation: VectorTranslation",
        "Local Space: Bool"
      ],
      "outputs": [
        "Instances: Geometry"
      ],
      "properties": [],
      "description": "Move top-level geometry instances in local or global space"
    },
    "GeometryNodeTriangulate": {
      "inputs": [
        "Mesh: Geometry",
        "Selection: Bool"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [
        {
          "name": "quad_method",
          "description": "Method for splitting the quads into triangles",
          "type": "ENUM",
          "values": [
            "BEAUTY",
            "FIXED",
            "FIXED_ALTERNATE",
            "SHORTEST_DIAGONAL",
            "LONGEST_DIAGONAL"
          ]
        },
        {
          "name": "ngon_method",
          "description": "Method for splitting the n-gons into triangles",
          "type": "ENUM",
          "values": [
            "BEAUTY",
            "CLIP"
          ]
        }
      ],
      "description": "Convert all faces in a mesh to triangular faces"
    },
    "GeometryNodeTrimCurve": {
      "inputs": [
        "Curve: Geometry",
        "Selection: Bool",
        "Start: FloatFactor",
        "End: FloatFactor",
        "Start: FloatDistance",
        "End: FloatDistance"
      ],
      "outputs": [
        "Curve: Geometry"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "How to find endpoint positions for the trimmed spline",
          "type": "ENUM",
          "values": [
            "FACTOR",
            "LENGTH"
          ]
        }
      ],
      "description": "Shorten curves by removing portions at the start or end"
    },
    "GeometryNodeUVPackIslands": {
      "inputs": [
        "UV: Vector",
        "Selection: Bool",
        "Margin: Float",
        "Rotate: Bool"
      ],
      "outputs": [
        "UV: Vector"
      ],
      "properties": [],
      "description": "Scale islands of a UV map and move them so they fill the UV space as much as possible"
    },
    "GeometryNodeUVUnwrap": {
      "inputs": [
        "Selection: Bool",
        "Seam: Bool",
        "Margin: Float",
        "Fill Holes: Bool"
      ],
      "outputs": [
        "UV: Vector"
      ],
      "properties": [
        {
          "name": "method",
          "type": "ENUM",
          "values": [
            "ANGLE_BASED",
            "CONFORMAL"
          ]
        }
      ],
      "description": "Generate a UV map based on seam edges"
    },
    "GeometryNodeVertexOfCorner": {
      "inputs": [
        "Corner Index: Int"
      ],
      "outputs": [
        "Vertex Index: Int"
      ],
      "properties": [],
      "description": "Retrieve the vertex each face corner is attached to"
    },
    "GeometryNodeViewer": {
      "inputs": [
        "Geometry: Geometry",
        "Value: Float"
      ],
      "outputs": [],
      "properties": [
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        },
        {
          "name": "domain",
          "description": "Domain to evaluate the field on",
          "type": "ENUM",
          "values": [
            "AUTO",
            "POINT",
            "EDGE",
            "FACE",
            "CORNER",
            "CURVE",
            "INSTANCE",
            "LAYER"
          ]
        }
      ],
      "description": "Display the input data in the Spreadsheet Editor"
    },
    "GeometryNodeViewportTransform": {
      "inputs": [],
      "outputs": [
        "Projection: Matrix",
        "View: Matrix",
        "Is Orthographic: Bool"
      ],
      "properties": [],
      "description": "Retrieve the view direction and location of the 3D viewport"
    },
    "GeometryNodeVolumeCube": {
      "inputs": [
        "Density: Float",
        "Background: Float",
        "Min: Vector",
        "Max: Vector",
        "Resolution X: Int",
        "Resolution Y: Int",
        "Resolution Z: Int"
      ],
      "outputs": [
        "Volume: Geometry"
      ],
      "properties": [],
      "description": "Generate a dense volume with a field that controls the density at each grid voxel based on its position"
    },
    "GeometryNodeVolumeToMesh": {
      "inputs": [
        "Volume: Geometry",
        "Voxel Size: FloatDistance",
        "Voxel Amount: Float",
        "Threshold: Float",
        "Adaptivity: FloatFactor"
      ],
      "outputs": [
        "Mesh: Geometry"
      ],
      "properties": [
        {
          "name": "resolution_mode",
          "description": "How the voxel size is specified",
          "type": "ENUM",
          "values": [
            "GRID",
            "VOXEL_AMOUNT",
            "VOXEL_SIZE"
          ]
        }
      ],
      "description": "Generate a mesh on the \"surface\" of a volume"
    },
    "FunctionNodeAlignEulerToVector": {
      "inputs": [
        "Rotation: VectorEuler",
        "Factor: FloatFactor",
        "Vector: Vector"
      ],
      "outputs": [
        "Rotation: VectorEuler"
      ],
      "properties": [
        {
          "name": "axis",
          "description": "Axis to align to the vector",
          "type": "ENUM",
          "values": [
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "pivot_axis",
          "description": "Axis to rotate around",
          "type": "ENUM",
          "values": [
            "AUTO",
            "X",
            "Y",
            "Z"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeAlignRotationToVector": {
      "inputs": [
        "Rotation: Rotation",
        "Factor: FloatFactor",
        "Vector: VectorXYZ"
      ],
      "outputs": [
        "Rotation: Rotation"
      ],
      "properties": [
        {
          "name": "axis",
          "description": "Axis to align to the vector",
          "type": "ENUM",
          "values": [
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "pivot_axis",
          "description": "Axis to rotate around",
          "type": "ENUM",
          "values": [
            "AUTO",
            "X",
            "Y",
            "Z"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeAxesToRotation": {
      "inputs": [
        "Primary Axis: Vector",
        "Secondary Axis: Vector"
      ],
      "outputs": [
        "Rotation: Rotation"
      ],
      "properties": [
        {
          "name": "primary_axis",
          "description": "Axis that is aligned exactly to the provided primary direction",
          "type": "ENUM",
          "values": [
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "secondary_axis",
          "description": "Axis that is aligned as well as possible given the alignment of the primary axis",
          "type": "ENUM",
          "values": [
            "X",
            "Y",
            "Z"
          ]
        }
      ],
      "description": "Create a rotation from a primary and (ideally orthogonal) secondary axis"
    },
    "FunctionNodeAxisAngleToRotation": {
      "inputs": [
        "Axis: Vector",
        "Angle: FloatAngle"
      ],
      "outputs": [
        "Rotation: Rotation"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeBooleanMath": {
      "inputs": [
        "Boolean: Bool",
        "Boolean: Bool"
      ],
      "outputs": [
        "Boolean: Bool"
      ],
      "properties": [
        {
          "name": "operation",
          "type": "ENUM",
          "values": [
            "AND",
            "OR",
            "NOT",
            "NAND",
            "NOR",
            "XNOR",
            "XOR",
            "IMPLY",
            "NIMPLY"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeCombineColor": {
      "inputs": [
        "Red: FloatFactor",
        "Green: FloatFactor",
        "Blue: FloatFactor",
        "Alpha: FloatFactor"
      ],
      "outputs": [
        "Color: Color"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Mode of color processing",
          "type": "ENUM",
          "values": [
            "RGB",
            "HSV",
            "HSL"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeCombineMatrix": {
      "inputs": [
        "Column 1 Row 1: Float",
        "Column 1 Row 2: Float",
        "Column 1 Row 3: Float",
        "Column 1 Row 4: Float",
        "Column 2 Row 1: Float",
        "Column 2 Row 2: Float",
        "Column 2 Row 3: Float",
        "Column 2 Row 4: Float",
        "Column 3 Row 1: Float",
        "Column 3 Row 2: Float",
        "Column 3 Row 3: Float",
        "Column 3 Row 4: Float",
        "Column 4 Row 1: Float",
        "Column 4 Row 2: Float",
        "Column 4 Row 3: Float",
        "Column 4 Row 4: Float"
      ],
      "outputs": [
        "Matrix: Matrix"
      ],
      "properties": [],
      "description": "Construct a 4x4 matrix from its individual values"
    },
    "FunctionNodeCombineTransform": {
      "inputs": [
        "Translation: VectorTranslation",
        "Rotation: Rotation",
        "Scale: VectorXYZ"
      ],
      "outputs": [
        "Transform: Matrix"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeCompare": {
      "inputs": [
        "A: Float",
        "B: Float",
        "A: Int",
        "B: Int",
        "A: Vector",
        "B: Vector",
        "A: Color",
        "B: Color",
        "A: String",
        "B: String",
        "C: Float",
        "Angle: FloatAngle",
        "Epsilon: Float"
      ],
      "outputs": [
        "Result: Bool"
      ],
      "properties": [
        {
          "name": "operation",
          "type": "ENUM",
          "values": [
            "LESS_THAN",
            "LESS_EQUAL",
            "GREATER_THAN",
            "GREATER_EQUAL",
            "EQUAL",
            "NOT_EQUAL",
            "BRIGHTER",
            "DARKER"
          ]
        },
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "BOOLEAN",
            "VECTOR",
            "ROTATION",
            "MATRIX",
            "STRING",
            "MENU",
            "RGBA",
            "OBJECT",
            "IMAGE",
            "GEOMETRY",
            "COLLECTION",
            "TEXTURE",
            "MATERIAL"
          ]
        },
        {
          "name": "mode",
          "type": "ENUM",
          "values": [
            "ELEMENT",
            "LENGTH",
            "AVERAGE",
            "DOT_PRODUCT",
            "DIRECTION"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeEulerToRotation": {
      "inputs": [
        "Euler: VectorEuler"
      ],
      "outputs": [
        "Rotation: Rotation"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeFindInString": {
      "inputs": [
        "String: String",
        "Search: String"
      ],
      "outputs": [
        "First Found: Int",
        "Count: Int"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeFloatToInt": {
      "inputs": [
        "Float: Float"
      ],
      "outputs": [
        "Integer: Int"
      ],
      "properties": [
        {
          "name": "rounding_mode",
          "description": "Method used to convert the float to an integer",
          "type": "ENUM",
          "values": [
            "ROUND",
            "FLOOR",
            "CEILING",
            "TRUNCATE"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeHashValue": {
      "inputs": [
        "Value: Int",
        "Seed: Int"
      ],
      "outputs": [
        "Hash: Int"
      ],
      "properties": [
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "BOOLEAN",
            "VECTOR",
            "ROTATION",
            "MATRIX",
            "STRING",
            "MENU",
            "RGBA",
            "OBJECT",
            "IMAGE",
            "GEOMETRY",
            "COLLECTION",
            "TEXTURE",
            "MATERIAL"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeInputBool": {
      "inputs": [
        "Boolean: Bool"
      ],
      "outputs": [
        "Boolean: Bool"
      ],
      "properties": [
        {
          "name": "boolean",
          "description": "Input value used for unconnected socket",
          "type": "BOOLEAN"
        }
      ],
      "description": ""
    },
    "FunctionNodeInputColor": {
      "inputs": [
        "Color: Color"
      ],
      "outputs": [
        "Color: Color"
      ],
      "properties": [
        {
          "name": "value",
          "type": "FLOAT"
        }
      ],
      "description": ""
    },
    "FunctionNodeInputInt": {
      "inputs": [
        "Integer: Int"
      ],
      "outputs": [
        "Integer: Int"
      ],
      "properties": [
        {
          "name": "integer",
          "description": "Input value used for unconnected socket",
          "type": "INT"
        }
      ],
      "description": ""
    },
    "FunctionNodeInputRotation": {
      "inputs": [
        "Rotation: Rotation"
      ],
      "outputs": [
        "Rotation: Rotation"
      ],
      "properties": [
        {
          "name": "rotation_euler",
          "description": "Input value used for unconnected socket",
          "type": "FLOAT"
        }
      ],
      "description": ""
    },
    "FunctionNodeInputString": {
      "inputs": [
        "String: String"
      ],
      "outputs": [
        "String: String"
      ],
      "properties": [
        {
          "name": "string",
          "type": "STRING"
        }
      ],
      "description": ""
    },
    "FunctionNodeInputVector": {
      "inputs": [
        "Vector: Vector"
      ],
      "outputs": [
        "Vector: Vector"
      ],
      "properties": [
        {
          "name": "vector",
          "type": "FLOAT"
        }
      ],
      "description": ""
    },
    "FunctionNodeIntegerMath": {
      "inputs": [
        "Value: Int",
        "Value: Int",
        "Value: Int"
      ],
      "outputs": [
        "Value: Int"
      ],
      "properties": [
        {
          "name": "operation",
          "type": "ENUM",
          "values": [
            "ADD",
            "SUBTRACT",
            "MULTIPLY",
            "DIVIDE",
            "MULTIPLY_ADD",
            "ABSOLUTE",
            "NEGATE",
            "POWER",
            "MINIMUM",
            "MAXIMUM",
            "SIGN",
            "DIVIDE_ROUND",
            "DIVIDE_FLOOR",
            "DIVIDE_CEIL",
            "FLOORED_MODULO",
            "MODULO",
            "GCD",
            "LCM"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeInvertMatrix": {
      "inputs": [
        "Matrix: Matrix"
      ],
      "outputs": [
        "Matrix: Matrix",
        "Invertible: Bool"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeInvertRotation": {
      "inputs": [
        "Rotation: Rotation"
      ],
      "outputs": [
        "Rotation: Rotation"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeMatrixDeterminant": {
      "inputs": [
        "Matrix: Matrix"
      ],
      "outputs": [
        "Determinant: Float"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeMatrixMultiply": {
      "inputs": [
        "Matrix: Matrix",
        "Matrix: Matrix"
      ],
      "outputs": [
        "Matrix: Matrix"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeProjectPoint": {
      "inputs": [
        "Vector: VectorXYZ",
        "Transform: Matrix"
      ],
      "outputs": [
        "Vector: VectorXYZ"
      ],
      "properties": [],
      "description": "Project a point using a matrix, using location, rotation, scale, and perspective divide"
    },
    "FunctionNodeQuaternionToRotation": {
      "inputs": [
        "W: Float",
        "X: Float",
        "Y: Float",
        "Z: Float"
      ],
      "outputs": [
        "Rotation: Rotation"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeRandomValue": {
      "inputs": [
        "Min: Vector",
        "Max: Vector",
        "Min: Float",
        "Max: Float",
        "Min: Int",
        "Max: Int",
        "Probability: FloatFactor",
        "ID: Int",
        "Seed: Int"
      ],
      "outputs": [
        "Value: Vector",
        "Value: Float",
        "Value: Int",
        "Value: Bool"
      ],
      "properties": [
        {
          "name": "data_type",
          "description": "Type of data stored in attribute",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT",
            "FLOAT_VECTOR",
            "FLOAT_COLOR",
            "BYTE_COLOR",
            "STRING",
            "BOOLEAN",
            "FLOAT2",
            "INT8",
            "INT16_2D",
            "INT32_2D",
            "QUATERNION",
            "FLOAT4X4"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeReplaceString": {
      "inputs": [
        "String: String",
        "Find: String",
        "Replace: String"
      ],
      "outputs": [
        "String: String"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeRotateEuler": {
      "inputs": [
        "Rotation: VectorEuler",
        "Rotate By: VectorEuler",
        "Axis: VectorXYZ",
        "Angle: FloatAngle"
      ],
      "outputs": [
        "Rotation: Vector"
      ],
      "properties": [
        {
          "name": "rotation_type",
          "description": "Method used to describe the rotation",
          "type": "ENUM",
          "values": [
            "AXIS_ANGLE",
            "EULER"
          ]
        },
        {
          "name": "space",
          "description": "Base orientation for rotation",
          "type": "ENUM",
          "values": [
            "OBJECT",
            "LOCAL"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeRotateRotation": {
      "inputs": [
        "Rotation: Rotation",
        "Rotate By: Rotation"
      ],
      "outputs": [
        "Rotation: Rotation"
      ],
      "properties": [
        {
          "name": "rotation_space",
          "description": "Base orientation for the rotation",
          "type": "ENUM",
          "values": [
            "GLOBAL",
            "LOCAL"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeRotateVector": {
      "inputs": [
        "Vector: Vector",
        "Rotation: Rotation"
      ],
      "outputs": [
        "Vector: Vector"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeRotationToAxisAngle": {
      "inputs": [
        "Rotation: Rotation"
      ],
      "outputs": [
        "Axis: Vector",
        "Angle: FloatAngle"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeRotationToEuler": {
      "inputs": [
        "Rotation: Rotation"
      ],
      "outputs": [
        "Euler: VectorEuler"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeRotationToQuaternion": {
      "inputs": [
        "Rotation: Rotation"
      ],
      "outputs": [
        "W: Float",
        "X: Float",
        "Y: Float",
        "Z: Float"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeSeparateColor": {
      "inputs": [
        "Color: Color"
      ],
      "outputs": [
        "Red: Float",
        "Green: Float",
        "Blue: Float",
        "Alpha: Float"
      ],
      "properties": [
        {
          "name": "mode",
          "description": "Mode of color processing",
          "type": "ENUM",
          "values": [
            "RGB",
            "HSV",
            "HSL"
          ]
        }
      ],
      "description": ""
    },
    "FunctionNodeSeparateMatrix": {
      "inputs": [
        "Matrix: Matrix"
      ],
      "outputs": [
        "Column 1 Row 1: Float",
        "Column 1 Row 2: Float",
        "Column 1 Row 3: Float",
        "Column 1 Row 4: Float",
        "Column 2 Row 1: Float",
        "Column 2 Row 2: Float",
        "Column 2 Row 3: Float",
        "Column 2 Row 4: Float",
        "Column 3 Row 1: Float",
        "Column 3 Row 2: Float",
        "Column 3 Row 3: Float",
        "Column 3 Row 4: Float",
        "Column 4 Row 1: Float",
        "Column 4 Row 2: Float",
        "Column 4 Row 3: Float",
        "Column 4 Row 4: Float"
      ],
      "properties": [],
      "description": "Split a 4x4 matrix into its individual values"
    },
    "FunctionNodeSeparateTransform": {
      "inputs": [
        "Transform: Matrix"
      ],
      "outputs": [
        "Translation: VectorTranslation",
        "Rotation: Rotation",
        "Scale: VectorXYZ"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeSliceString": {
      "inputs": [
        "String: String",
        "Position: Int",
        "Length: Int"
      ],
      "outputs": [
        "String: String"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeStringLength": {
      "inputs": [
        "String: String"
      ],
      "outputs": [
        "Length: Int"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeTransformDirection": {
      "inputs": [
        "Direction: VectorXYZ",
        "Transform: Matrix"
      ],
      "outputs": [
        "Direction: VectorXYZ"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeTransformPoint": {
      "inputs": [
        "Vector: VectorXYZ",
        "Transform: Matrix"
      ],
      "outputs": [
        "Vector: VectorXYZ"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeTransposeMatrix": {
      "inputs": [
        "Matrix: Matrix"
      ],
      "outputs": [
        "Matrix: Matrix"
      ],
      "properties": [],
      "description": ""
    },
    "FunctionNodeValueToString": {
      "inputs": [
        "Value: Float",
        "Decimals: Int"
      ],
      "outputs": [
        "String: String"
      ],
      "properties": [
        {
          "name": "data_type",
          "type": "ENUM",
          "values": [
            "FLOAT",
            "INT"
          ]
        }
      ],
      "description": ""
    },
    "ShaderNodeTexChecker": {
      "inputs": [
        "Vector: Vector",
        "Color1: Color",
        "Color2: Color",
        "Scale: Float"
      ],
      "outputs": [
        "Color: Color",
        "Fac: Float"
      ],
      "properties": [
        {
          "name": "texture_mapping",
          "description": "Texture coordinate mapping settings",
          "type": "POINTER"
        },
        {
          "name": "color_mapping",
          "description": "Color mapping settings",
          "type": "POINTER"
        }
      ],
      "description": "Generate a checkerboard texture"
    },
    "ShaderNodeTexBrick": {
      "inputs": [
        "Vector: Vector",
        "Color1: Color",
        "Color2: Color",
        "Mortar: Color",
        "Scale: Float",
        "Mortar Size: Float",
        "Mortar Smooth: Float",
        "Bias: Float",
        "Brick Width: Float",
        "Row Height: Float"
      ],
      "outputs": [
        "Color: Color",
        "Fac: Float"
      ],
      "properties": [
        {
          "name": "texture_mapping",
          "description": "Texture coordinate mapping settings",
          "type": "POINTER"
        },
        {
          "name": "color_mapping",
          "description": "Color mapping settings",
          "type": "POINTER"
        },
        {
          "name": "offset_frequency",
          "description": "How often rows are offset. A value of 2 gives an even/uneven pattern of rows.",
          "type": "INT"
        },
        {
          "name": "squash_frequency",
          "description": "How often rows consist of \"squished\" bricks",
          "type": "INT"
        },
        {
          "name": "offset",
          "description": "Determines the brick offset of the various rows",
          "type": "FLOAT"
        },
        {
          "name": "squash",
          "description": "Factor to adjust the brick's width for particular rows determined by the Offset Frequency",
          "type": "FLOAT"
        }
      ],
      "description": "Generate a procedural texture producing bricks"
    },
    "ShaderNodeTexNoise": {
      "inputs": [
        "Vector: Vector",
        "W: Float",
        "Scale: Float",
        "Detail: Float",
        "Roughness: FloatFactor",
        "Lacunarity: Float",
        "Offset: Float",
        "Gain: Float",
        "Distortion: Float"
      ],
      "outputs": [
        "Fac: Float",
        "Color: Color"
      ],
      "properties": [
        {
          "name": "texture_mapping",
          "description": "Texture coordinate mapping settings",
          "type": "POINTER"
        },
        {
          "name": "color_mapping",
          "description": "Color mapping settings",
          "type": "POINTER"
        },
        {
          "name": "noise_dimensions",
          "description": "Number of dimensions to output noise for",
          "type": "ENUM",
          "values": [
            "1D",
            "2D",
            "3D",
            "4D"
          ]
        },
        {
          "name": "noise_type",
          "description": "Type of the Noise texture",
          "type": "ENUM",
          "values": [
            "MULTIFRACTAL",
            "RIDGED_MULTIFRACTAL",
            "HYBRID_MULTIFRACTAL",
            "FBM",
            "HETERO_TERRAIN"
          ]
        },
        {
          "name": "normalize",
          "description": "Normalize outputs to 0.0 to 1.0 range",
          "type": "BOOLEAN"
        }
      ],
      "description": "Generate fractal Perlin noise"
    },
    "ShaderNodeTexVoronoi": {
      "inputs": [
        "Vector: Vector",
        "W: Float",
        "Scale: Float",
        "Detail: Float",
        "Roughness: FloatFactor",
        "Lacunarity: Float",
        "Smoothness: FloatFactor",
        "Exponent: Float",
        "Randomness: FloatFactor"
      ],
      "outputs": [
        "Distance: Float",
        "Color: Color",
        "Position: Vector",
        "W: Float",
        "Radius: Float"
      ],
      "properties": [
        {
          "name": "texture_mapping",
          "description": "Texture coordinate mapping settings",
          "type": "POINTER"
        },
        {
          "name": "color_mapping",
          "description": "Color mapping settings",
          "type": "POINTER"
        },
        {
          "name": "voronoi_dimensions",
          "description": "Number of dimensions to output noise for",
          "type": "ENUM",
          "values": [
            "1D",
            "2D",
            "3D",
            "4D"
          ]
        },
        {
          "name": "distance",
          "description": "The distance metric used to compute the texture",
          "type": "ENUM",
          "values": [
            "EUCLIDEAN",
            "MANHATTAN",
            "CHEBYCHEV",
            "MINKOWSKI"
          ]
        },
        {
          "name": "feature",
          "description": "The Voronoi feature that the node will compute",
          "type": "ENUM",
          "values": [
            "F1",
            "F2",
            "SMOOTH_F1",
            "DISTANCE_TO_EDGE",
            "N_SPHERE_RADIUS"
          ]
        },
        {
          "name": "normalize",
          "description": "Normalize output Distance to 0.0 to 1.0 range",
          "type": "BOOLEAN"
        }
      ],
      "description": "Generate Worley noise based on the distance to random points. Typically used to generate textures such as stones, water, or biological cells"
    },
    "ShaderNodeTexWhiteNoise": {
      "inputs": [
        "Vector: Vector",
        "W: Float"
      ],
      "outputs": [
        "Value: Float",
        "Color: Color"
      ],
      "properties": [
        {
          "name": "noise_dimensions",
          "description": "Number of dimensions to output noise for",
          "type": "ENUM",
          "values": [
            "1D",
            "2D",
            "3D",
            "4D"
          ]
        }
      ],
      "description": "Return a random value or color based on an input seed"
    },
    "ShaderNodeTexGabor": {
      "inputs": [
        "Vector: Vector",
        "Scale: Float",
        "Frequency: Float",
        "Anisotropy: FloatFactor",
        "Orientation: FloatAngle",
        "Orientation: VectorDirection"
      ],
      "outputs": [
        "Value: Float",
        "Phase: Float",
        "Intensity: Float"
      ],
      "properties": [
        {
          "name": "texture_mapping",
          "description": "Texture coordinate mapping settings",
          "type": "POINTER"
        },
        {
          "name": "color_mapping",
          "description": "Color mapping settings",
          "type": "POINTER"
        },
        {
          "name": "gabor_type",
          "description": "The type of Gabor noise to evaluate",
          "type": "ENUM",
          "values": [
            "2D",
            "3D"
          ]
        }
      ],
      "description": "Generate Gabor noise"
    },
    "ShaderNodeVectorMath": {
      "inputs": [
        "Vector: Vector",
        "Vector: Vector",
        "Vector: Vector",
        "Scale: Float"
      ],
      "outputs": [
        "Vector: Vector",
        "Value: Float"
      ],
      "properties": [
        {
          "name": "operation",
          "type": "ENUM",
          "values": [
            "ADD",
            "SUBTRACT",
            "MULTIPLY",
            "DIVIDE",
            "MULTIPLY_ADD",
            "CROSS_PRODUCT",
            "PROJECT",
            "REFLECT",
            "REFRACT",
            "FACEFORWARD",
            "DOT_PRODUCT",
            "DISTANCE",
            "LENGTH",
            "SCALE",
            "NORMALIZE",
            "ABSOLUTE",
            "MINIMUM",
            "MAXIMUM",
            "FLOOR",
            "CEIL",
            "FRACTION",
            "MODULO",
            "WRAP",
            "SNAP",
            "SINE",
            "COSINE",
            "TANGENT"
          ]
        }
      ],
      "description": "Perform vector math operation"
    },
    "ShaderNodeMath": {
      "inputs": [
        "Value: Float",
        "Value: Float",
        "Value: Float"
      ],
      "outputs": [
        "Value: Float"
      ],
      "properties": [
        {
          "name": "operation",
          "type": "ENUM",
          "values": [
            "ADD",
            "SUBTRACT",
            "MULTIPLY",
            "DIVIDE",
            "MULTIPLY_ADD",
            "POWER",
            "LOGARITHM",
            "SQRT",
            "INVERSE_SQRT",
            "ABSOLUTE",
            "EXPONENT",
            "MINIMUM",
            "MAXIMUM",
            "LESS_THAN",
            "GREATER_THAN",
            "SIGN",
            "COMPARE",
            "SMOOTH_MIN",
            "SMOOTH_MAX",
            "ROUND",
            "FLOOR",
            "CEIL",
            "TRUNC",
            "FRACT",
            "MODULO",
            "FLOORED_MODULO",
            "WRAP",
            "SNAP",
            "PINGPONG",
            "SINE",
            "COSINE",
            "TANGENT",
            "ARCSINE",
            "ARCCOSINE",
            "ARCTANGENT",
            "ARCTAN2",
            "SINH",
            "COSH",
            "TANH",
            "RADIANS",
            "DEGREES"
          ]
        },
        {
          "name": "use_clamp",
          "description": "Clamp result of the node to 0.0 to 1.0 range",
          "type": "BOOLEAN"
        }
      ],
      "description": "Perform math operations"
    },
    "ShaderNodeClamp": {
      "inputs": [
        "Value: Float",
        "Min: Float",
        "Max: Float"
      ],
      "outputs": [
        "Result: Float"
      ],
      "properties": [
        {
          "name": "clamp_type",
          "type": "ENUM",
          "values": [
            "MINMAX",
            "RANGE"
          ]
        }
      ],
      "description": "Clamp a value between a minimum and a maximum"
    },
    "ShaderNodeSeparateXYZ": {
      "inputs": [
        "Vector: Vector"
      ],
      "outputs": [
        "X: Float",
        "Y: Float",
        "Z: Float"
      ],
      "properties": [],
      "description": "Split a vector into its X, Y, and Z components"
    },
    "ShaderNodeCombineXYZ": {
      "inputs": [
        "X: Float",
        "Y: Float",
        "Z: Float"
      ],
      "outputs": [
        "Vector: Vector"
      ],
      "properties": [],
      "description": "Create a vector from X, Y, and Z components"
    }
  }
  