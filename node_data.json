{
    "GeometryNodeAccumulateField": {
      "GeometryNodeAccumulateField": {
        "inputs": [
          "Value: Float",
          "Group ID: Int"
        ],
        "outputs": [
          "Leading: Float",
          "Trailing: Float",
          "Total: Float"
        ],
        "description": "Add the values of an evaluated field together and output the running total for each element"
      }
    },
    "GeometryNodeAttributeDomainSize": {
      "GeometryNodeAttributeDomainSize": {
        "inputs": [
          "Geometry: Geometry"
        ],
        "outputs": [
          "Point Count: Int",
          "Edge Count: Int",
          "Face Count: Int",
          "Face Corner Count: Int",
          "Spline Count: Int",
          "Instance Count: Int",
          "Layer Count: Int"
        ],
        "description": "Retrieve the number of elements in a geometry for each attribute domain"
      }
    },
    "GeometryNodeAttributeStatistic": {
      "GeometryNodeAttributeStatistic": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Attribute: Float"
        ],
        "outputs": [
          "Mean: Float",
          "Median: Float",
          "Sum: Float",
          "Min: Float",
          "Max: Float",
          "Range: Float",
          "Standard Deviation: Float",
          "Variance: Float"
        ],
        "description": "Calculate statistics about a data set from a field evaluated on a geometry"
      }
    },
    "GeometryNodeBake": {
      "GeometryNodeBake": {
        "inputs": [
          "Geometry: Geometry",
          ": Virtual"
        ],
        "outputs": [
          "Geometry: Geometry",
          ": Virtual"
        ],
        "description": "Cache the incoming data so that it can be used without recomputation"
      }
    },
    "GeometryNodeBlurAttribute": {
      "GeometryNodeBlurAttribute": {
        "inputs": [
          "Value: Float",
          "Iterations: Int",
          "Weight: FloatFactor"
        ],
        "outputs": [
          "Value: Float"
        ],
        "description": "Mix attribute values of neighboring elements"
      }
    },
    "GeometryNodeBoundBox": {
      "GeometryNodeBoundBox": {
        "inputs": [
          "Geometry: Geometry"
        ],
        "outputs": [
          "Bounding Box: Geometry",
          "Min: Vector",
          "Max: Vector"
        ],
        "description": "Calculate the limits of a geometry's positions and generate a box mesh with those dimensions"
      }
    },
    "GeometryNodeCaptureAttribute": {
      "GeometryNodeCaptureAttribute": {
        "inputs": [
          "Geometry: Geometry",
          ": Virtual"
        ],
        "outputs": [
          "Geometry: Geometry",
          ": Virtual"
        ],
        "description": "Store the result of a field on a geometry and output the data as a node socket. Allows remembering or interpolating data as the geometry changes, such as positions before deformation"
      }
    },
    "GeometryNodeCollectionInfo": {
      "GeometryNodeCollectionInfo": {
        "inputs": [
          "Collection: Collection",
          "Separate Children: Bool",
          "Reset Children: Bool"
        ],
        "outputs": [
          "Instances: Geometry"
        ],
        "description": "Retrieve geometry instances from a collection"
      }
    },
    "GeometryNodeConvexHull": {
      "GeometryNodeConvexHull": {
        "inputs": [
          "Geometry: Geometry"
        ],
        "outputs": [
          "Convex Hull: Geometry"
        ],
        "description": "Create a mesh that encloses all points in the input geometry with the smallest number of points"
      }
    },
    "GeometryNodeCornersOfEdge": {
      "GeometryNodeCornersOfEdge": {
        "inputs": [
          "Edge Index: Int",
          "Weights: Float",
          "Sort Index: Int"
        ],
        "outputs": [
          "Corner Index: Int",
          "Total: Int"
        ],
        "description": "Retrieve face corners connected to edges"
      }
    },
    "GeometryNodeCornersOfFace": {
      "GeometryNodeCornersOfFace": {
        "inputs": [
          "Face Index: Int",
          "Weights: Float",
          "Sort Index: Int"
        ],
        "outputs": [
          "Corner Index: Int",
          "Total: Int"
        ],
        "description": "Retrieve corners that make up a face"
      }
    },
    "GeometryNodeCornersOfVertex": {
      "GeometryNodeCornersOfVertex": {
        "inputs": [
          "Vertex Index: Int",
          "Weights: Float",
          "Sort Index: Int"
        ],
        "outputs": [
          "Corner Index: Int",
          "Total: Int"
        ],
        "description": "Retrieve face corners connected to vertices"
      }
    },
    "GeometryNodeCurveArc": {
      "GeometryNodeCurveArc": {
        "inputs": [
          "Resolution: IntUnsigned",
          "Start: VectorTranslation",
          "Middle: VectorTranslation",
          "End: VectorTranslation",
          "Radius: FloatDistance",
          "Start Angle: FloatAngle",
          "Sweep Angle: FloatAngle",
          "Offset Angle: FloatAngle",
          "Connect Center: Bool",
          "Invert Arc: Bool"
        ],
        "outputs": [
          "Curve: Geometry",
          "Center: Vector",
          "Normal: Vector",
          "Radius: Float"
        ],
        "description": "Generate a poly spline arc"
      }
    },
    "GeometryNodeCurveEndpointSelection": {
      "GeometryNodeCurveEndpointSelection": {
        "inputs": [
          "Start Size: Int",
          "End Size: Int"
        ],
        "outputs": [
          "Selection: Bool"
        ],
        "description": "Provide a selection for an arbitrary number of endpoints in each spline"
      }
    },
    "GeometryNodeCurveHandleTypeSelection": {
      "GeometryNodeCurveHandleTypeSelection": {
        "inputs": [],
        "outputs": [
          "Selection: Bool"
        ],
        "description": "Provide a selection based on the handle types of B\u00e9zier control points"
      }
    },
    "GeometryNodeCurveLength": {
      "GeometryNodeCurveLength": {
        "inputs": [
          "Curve: Geometry"
        ],
        "outputs": [
          "Length: Float"
        ],
        "description": "Retrieve the length of all splines added together"
      }
    },
    "GeometryNodeCurveOfPoint": {
      "GeometryNodeCurveOfPoint": {
        "inputs": [
          "Point Index: Int"
        ],
        "outputs": [
          "Curve Index: Int",
          "Index in Curve: Int"
        ],
        "description": "Retrieve the curve a control point is part of"
      }
    },
    "GeometryNodeCurvePrimitiveBezierSegment": {
      "GeometryNodeCurvePrimitiveBezierSegment": {
        "inputs": [
          "Resolution: IntUnsigned",
          "Start: VectorTranslation",
          "Start Handle: VectorTranslation",
          "End Handle: VectorTranslation",
          "End: VectorTranslation"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Generate a 2D B\u00e9zier spline from the given control points and handles"
      }
    },
    "GeometryNodeCurvePrimitiveCircle": {
      "GeometryNodeCurvePrimitiveCircle": {
        "inputs": [
          "Resolution: Int",
          "Point 1: VectorTranslation",
          "Point 2: VectorTranslation",
          "Point 3: VectorTranslation",
          "Radius: FloatDistance"
        ],
        "outputs": [
          "Curve: Geometry",
          "Center: Vector"
        ],
        "description": "Generate a poly spline circle"
      }
    },
    "GeometryNodeCurvePrimitiveLine": {
      "GeometryNodeCurvePrimitiveLine": {
        "inputs": [
          "Start: VectorTranslation",
          "End: VectorTranslation",
          "Direction: Vector",
          "Length: FloatDistance"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Generate a poly spline line with two points"
      }
    },
    "GeometryNodeCurvePrimitiveQuadrilateral": {
      "GeometryNodeCurvePrimitiveQuadrilateral": {
        "inputs": [
          "Width: FloatDistance",
          "Height: FloatDistance",
          "Bottom Width: FloatDistance",
          "Top Width: FloatDistance",
          "Offset: FloatDistance",
          "Bottom Height: FloatDistance",
          "Top Height: FloatDistance",
          "Point 1: VectorTranslation",
          "Point 2: VectorTranslation",
          "Point 3: VectorTranslation",
          "Point 4: VectorTranslation"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Generate a polygon with four points"
      }
    },
    "GeometryNodeCurveQuadraticBezier": {
      "GeometryNodeCurveQuadraticBezier": {
        "inputs": [
          "Resolution: IntUnsigned",
          "Start: VectorTranslation",
          "Middle: VectorTranslation",
          "End: VectorTranslation"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Generate a poly spline in a parabola shape with control points positions"
      }
    },
    "GeometryNodeCurveSetHandles": {
      "GeometryNodeCurveSetHandles": {
        "inputs": [
          "Curve: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Set the handle type for the control points of a B\u00e9zier curve"
      }
    },
    "GeometryNodeCurveSpiral": {
      "GeometryNodeCurveSpiral": {
        "inputs": [
          "Resolution: IntUnsigned",
          "Rotations: Float",
          "Start Radius: FloatDistance",
          "End Radius: FloatDistance",
          "Height: FloatDistance",
          "Reverse: Bool"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Generate a poly spline in a spiral shape"
      }
    },
    "GeometryNodeCurveSplineType": {
      "GeometryNodeCurveSplineType": {
        "inputs": [
          "Curve: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Change the type of curves"
      }
    },
    "GeometryNodeCurveStar": {
      "GeometryNodeCurveStar": {
        "inputs": [
          "Points: IntUnsigned",
          "Inner Radius: FloatDistance",
          "Outer Radius: FloatDistance",
          "Twist: FloatAngle"
        ],
        "outputs": [
          "Curve: Geometry",
          "Outer Points: Bool"
        ],
        "description": "Generate a poly spline in a star pattern by connecting alternating points of two circles"
      }
    },
    "GeometryNodeCurveToMesh": {
      "GeometryNodeCurveToMesh": {
        "inputs": [
          "Curve: Geometry",
          "Profile Curve: Geometry",
          "Fill Caps: Bool"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Convert curves into a mesh, optionally with a custom profile shape defined by curves"
      }
    },
    "GeometryNodeCurveToPoints": {
      "GeometryNodeCurveToPoints": {
        "inputs": [
          "Curve: Geometry",
          "Count: Int",
          "Length: FloatDistance"
        ],
        "outputs": [
          "Points: Geometry",
          "Tangent: Vector",
          "Normal: Vector",
          "Rotation: Rotation"
        ],
        "description": "Generate a point cloud by sampling positions along curves"
      }
    },
    "GeometryNodeCurvesToGreasePencil": {
      "GeometryNodeCurvesToGreasePencil": {
        "inputs": [
          "Curves: Geometry",
          "Selection: Bool",
          "Instances as Layers: Bool"
        ],
        "outputs": [
          "Grease Pencil: Geometry"
        ],
        "description": "Convert the curves in each top-level instance into Grease Pencil layer"
      }
    },
    "GeometryNodeDeformCurvesOnSurface": {
      "GeometryNodeDeformCurvesOnSurface": {
        "inputs": [
          "Curves: Geometry"
        ],
        "outputs": [
          "Curves: Geometry"
        ],
        "description": "Translate and rotate curves based on changes between the object's original and evaluated surface mesh"
      }
    },
    "GeometryNodeDeleteGeometry": {
      "GeometryNodeDeleteGeometry": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Remove selected elements of a geometry"
      }
    },
    "GeometryNodeDistributePointsInGrid": {
      "GeometryNodeDistributePointsInGrid": {
        "inputs": [
          "Grid: Float",
          "Density: Float",
          "Seed: Int",
          "Spacing: VectorXYZ",
          "Threshold: Float"
        ],
        "outputs": [
          "Points: Geometry"
        ],
        "description": "Generate points inside a volume grid"
      }
    },
    "GeometryNodeDistributePointsInVolume": {
      "GeometryNodeDistributePointsInVolume": {
        "inputs": [
          "Volume: Geometry",
          "Density: Float",
          "Seed: Int",
          "Spacing: VectorXYZ",
          "Threshold: Float"
        ],
        "outputs": [
          "Points: Geometry"
        ],
        "description": "Generate points inside a volume"
      }
    },
    "GeometryNodeDistributePointsOnFaces": {
      "GeometryNodeDistributePointsOnFaces": {
        "inputs": [
          "Mesh: Geometry",
          "Selection: Bool",
          "Distance Min: FloatDistance",
          "Density Max: Float",
          "Density: Float",
          "Density Factor: FloatFactor",
          "Seed: Int"
        ],
        "outputs": [
          "Points: Geometry",
          "Normal: Vector",
          "Rotation: Rotation"
        ],
        "description": "Generate points spread out on the surface of a mesh"
      }
    },
    "GeometryNodeDualMesh": {
      "GeometryNodeDualMesh": {
        "inputs": [
          "Mesh: Geometry",
          "Keep Boundaries: Bool"
        ],
        "outputs": [
          "Dual Mesh: Geometry"
        ],
        "description": "Convert Faces into vertices and vertices into faces"
      }
    },
    "GeometryNodeDuplicateElements": {
      "GeometryNodeDuplicateElements": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Amount: Int"
        ],
        "outputs": [
          "Geometry: Geometry",
          "Duplicate Index: Int"
        ],
        "description": "Generate an arbitrary number copies of each selected input element"
      }
    },
    "GeometryNodeEdgePathsToCurves": {
      "GeometryNodeEdgePathsToCurves": {
        "inputs": [
          "Mesh: Geometry",
          "Start Vertices: Bool",
          "Next Vertex Index: Int"
        ],
        "outputs": [
          "Curves: Geometry"
        ],
        "description": "Output curves following paths across mesh edges"
      }
    },
    "GeometryNodeEdgePathsToSelection": {
      "GeometryNodeEdgePathsToSelection": {
        "inputs": [
          "Start Vertices: Bool",
          "Next Vertex Index: Int"
        ],
        "outputs": [
          "Selection: Bool"
        ],
        "description": "Output a selection of edges by following paths across mesh edges"
      }
    },
    "GeometryNodeEdgesOfCorner": {
      "GeometryNodeEdgesOfCorner": {
        "inputs": [
          "Corner Index: Int"
        ],
        "outputs": [
          "Next Edge Index: Int",
          "Previous Edge Index: Int"
        ],
        "description": "Retrieve the edges on both sides of a face corner"
      }
    },
    "GeometryNodeEdgesOfVertex": {
      "GeometryNodeEdgesOfVertex": {
        "inputs": [
          "Vertex Index: Int",
          "Weights: Float",
          "Sort Index: Int"
        ],
        "outputs": [
          "Edge Index: Int",
          "Total: Int"
        ],
        "description": "Retrieve the edges connected to each vertex"
      }
    },
    "GeometryNodeEdgesToFaceGroups": {
      "GeometryNodeEdgesToFaceGroups": {
        "inputs": [
          "Boundary Edges: Bool"
        ],
        "outputs": [
          "Face Group ID: Int"
        ],
        "description": "Group faces into regions surrounded by the selected boundary edges"
      }
    },
    "GeometryNodeExtrudeMesh": {
      "GeometryNodeExtrudeMesh": {
        "inputs": [
          "Mesh: Geometry",
          "Selection: Bool",
          "Offset: VectorTranslation",
          "Offset Scale: Float",
          "Individual: Bool"
        ],
        "outputs": [
          "Mesh: Geometry",
          "Top: Bool",
          "Side: Bool"
        ],
        "description": "Generate new vertices, edges, or faces from selected elements and move them based on an offset while keeping them connected by their boundary"
      }
    },
    "GeometryNodeFaceOfCorner": {
      "GeometryNodeFaceOfCorner": {
        "inputs": [
          "Corner Index: Int"
        ],
        "outputs": [
          "Face Index: Int",
          "Index in Face: Int"
        ],
        "description": "Retrieve the face each face corner is part of"
      }
    },
    "GeometryNodeFieldAtIndex": {
      "GeometryNodeFieldAtIndex": {
        "inputs": [
          "Index: Int",
          "Value: Float"
        ],
        "outputs": [
          "Value: Float"
        ],
        "description": "Retrieve data of other elements in the context's geometry"
      }
    },
    "GeometryNodeFieldOnDomain": {
      "GeometryNodeFieldOnDomain": {
        "inputs": [
          "Value: Float"
        ],
        "outputs": [
          "Value: Float"
        ],
        "description": "Retrieve values from a field on a different domain besides the domain from the context"
      }
    },
    "GeometryNodeFillCurve": {
      "GeometryNodeFillCurve": {
        "inputs": [
          "Curve: Geometry",
          "Group ID: Int"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Generate a mesh on the XY plane with faces on the inside of input curves"
      }
    },
    "GeometryNodeFilletCurve": {
      "GeometryNodeFilletCurve": {
        "inputs": [
          "Curve: Geometry",
          "Count: Int",
          "Radius: FloatDistance",
          "Limit Radius: Bool"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Round corners by generating circular arcs on each control point"
      }
    },
    "GeometryNodeFlipFaces": {
      "GeometryNodeFlipFaces": {
        "inputs": [
          "Mesh: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Reverse the order of the vertices and edges of selected faces, flipping their normal direction"
      }
    },
    "GeometryNodeForeachGeometryElementInput": {
      "GeometryNodeForeachGeometryElementInput": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          ": Virtual"
        ],
        "outputs": [
          "Index: Int",
          "Element: Geometry",
          ": Virtual"
        ],
        "description": ""
      }
    },
    "GeometryNodeForeachGeometryElementOutput": {
      "GeometryNodeForeachGeometryElementOutput": {
        "inputs": [
          ": Virtual",
          "Geometry: Geometry",
          ": Virtual"
        ],
        "outputs": [
          "Geometry: Geometry",
          ": Virtual",
          "Geometry: Geometry",
          ": Virtual"
        ],
        "description": ""
      }
    },
    "GeometryNodeGeometryToInstance": {
      "GeometryNodeGeometryToInstance": {
        "inputs": [
          "Geometry: Geometry"
        ],
        "outputs": [
          "Instances: Geometry"
        ],
        "description": "Convert each input geometry into an instance, which can be much faster than the Join Geometry node when the inputs are large"
      }
    },
    "GeometryNodeGetNamedGrid": {
      "GeometryNodeGetNamedGrid": {
        "inputs": [
          "Volume: Geometry",
          "Name: String",
          "Remove: Bool"
        ],
        "outputs": [
          "Volume: Geometry",
          "Grid: Float"
        ],
        "description": "Get volume grid from a volume geometry with the specified name"
      }
    },
    "GeometryNodeGizmoDial": {
      "GeometryNodeGizmoDial": {
        "inputs": [
          "Value: Float",
          "Position: VectorTranslation",
          "Up: VectorXYZ",
          "Screen Space: Bool",
          "Radius: Float"
        ],
        "outputs": [
          "Transform: Geometry"
        ],
        "description": "Show a dial gizmo in the viewport for a value"
      }
    },
    "GeometryNodeGizmoLinear": {
      "GeometryNodeGizmoLinear": {
        "inputs": [
          "Value: Float",
          "Position: VectorTranslation",
          "Direction: VectorXYZ"
        ],
        "outputs": [
          "Transform: Geometry"
        ],
        "description": "Show a linear gizmo in the viewport for a value"
      }
    },
    "GeometryNodeGizmoTransform": {
      "GeometryNodeGizmoTransform": {
        "inputs": [
          "Value: Matrix",
          "Position: VectorTranslation",
          "Rotation: Rotation"
        ],
        "outputs": [
          "Transform: Geometry"
        ],
        "description": "Show a transform gizmo in the viewport"
      }
    },
    "GeometryNodeGreasePencilToCurves": {
      "GeometryNodeGreasePencilToCurves": {
        "inputs": [
          "Grease Pencil: Geometry",
          "Selection: Bool",
          "Layers as Instances: Bool"
        ],
        "outputs": [
          "Curves: Geometry"
        ],
        "description": "Convert Grease Pencil layers into curve instances"
      }
    },
    "GeometryNodeGridToMesh": {
      "GeometryNodeGridToMesh": {
        "inputs": [
          "Grid: Float",
          "Threshold: Float",
          "Adaptivity: FloatFactor"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Generate a mesh on the \"surface\" of a volume grid"
      }
    },
    "GeometryNodeGroup": {
      "GeometryNodeGroup": {
        "inputs": [],
        "outputs": [],
        "description": ""
      }
    },
    "GeometryNodeImageInfo": {
      "GeometryNodeImageInfo": {
        "inputs": [
          "Image: Image",
          "Frame: Int"
        ],
        "outputs": [
          "Width: Int",
          "Height: Int",
          "Has Alpha: Bool",
          "Frame Count: Int",
          "FPS: Float"
        ],
        "description": "Retrieve information about an image"
      }
    },
    "GeometryNodeImageTexture": {
      "GeometryNodeImageTexture": {
        "inputs": [
          "Image: Image",
          "Vector: Vector",
          "Frame: Int"
        ],
        "outputs": [
          "Color: Color",
          "Alpha: Float"
        ],
        "description": "Sample values from an image texture"
      }
    },
    "GeometryNodeImportOBJ": {
      "GeometryNodeImportOBJ": {
        "inputs": [
          "Path: StringFilePath"
        ],
        "outputs": [
          "Instances: Geometry"
        ],
        "description": "Import geometry from an OBJ file"
      }
    },
    "GeometryNodeImportPLY": {
      "GeometryNodeImportPLY": {
        "inputs": [
          "Path: StringFilePath"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Import a point cloud from a PLY file"
      }
    },
    "GeometryNodeImportSTL": {
      "GeometryNodeImportSTL": {
        "inputs": [
          "Path: StringFilePath"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Import a mesh from an STL file"
      }
    },
    "GeometryNodeIndexOfNearest": {
      "GeometryNodeIndexOfNearest": {
        "inputs": [
          "Position: Vector",
          "Group ID: Int"
        ],
        "outputs": [
          "Index: Int",
          "Has Neighbor: Bool"
        ],
        "description": "Find the nearest element in a group. Similar to the \"Sample Nearest\" node"
      }
    },
    "GeometryNodeIndexSwitch": {
      "GeometryNodeIndexSwitch": {
        "inputs": [
          "Index: Int",
          "0: Geometry",
          "1: Geometry",
          ": Virtual"
        ],
        "outputs": [
          "Output: Geometry"
        ],
        "description": "Choose between an arbitrary number of values with an index"
      }
    },
    "GeometryNodeInputActiveCamera": {
      "GeometryNodeInputActiveCamera": {
        "inputs": [],
        "outputs": [
          "Active Camera: Object"
        ],
        "description": "Retrieve the scene's active camera"
      }
    },
    "GeometryNodeInputCollection": {
      "GeometryNodeInputCollection": {
        "inputs": [],
        "outputs": [
          "Collection: Collection"
        ],
        "description": "Output a single collection"
      }
    },
    "GeometryNodeInputCurveHandlePositions": {
      "GeometryNodeInputCurveHandlePositions": {
        "inputs": [
          "Relative: Bool"
        ],
        "outputs": [
          "Left: Vector",
          "Right: Vector"
        ],
        "description": "Retrieve the position of each B\u00e9zier control point's handles"
      }
    },
    "GeometryNodeInputCurveTilt": {
      "GeometryNodeInputCurveTilt": {
        "inputs": [],
        "outputs": [
          "Tilt: Float"
        ],
        "description": "Retrieve the angle at each control point used to twist the curve's normal around its tangent"
      }
    },
    "GeometryNodeInputEdgeSmooth": {
      "GeometryNodeInputEdgeSmooth": {
        "inputs": [],
        "outputs": [
          "Smooth: Bool"
        ],
        "description": "Retrieve whether each edge is marked for smooth or split normals"
      }
    },
    "GeometryNodeInputID": {
      "GeometryNodeInputID": {
        "inputs": [],
        "outputs": [
          "ID: Int"
        ],
        "description": "Retrieve a stable random identifier value from the \"id\" attribute on the point domain, or the index if the attribute does not exist"
      }
    },
    "GeometryNodeInputImage": {
      "GeometryNodeInputImage": {
        "inputs": [],
        "outputs": [
          "Image: Image"
        ],
        "description": "Input an image data-block"
      }
    },
    "GeometryNodeInputIndex": {
      "GeometryNodeInputIndex": {
        "inputs": [],
        "outputs": [
          "Index: Int"
        ],
        "description": "Retrieve an integer value indicating the position of each element in the list, starting at zero"
      }
    },
    "GeometryNodeInputInstanceRotation": {
      "GeometryNodeInputInstanceRotation": {
        "inputs": [],
        "outputs": [
          "Rotation: Rotation"
        ],
        "description": "Retrieve the rotation of each instance in the geometry"
      }
    },
    "GeometryNodeInputInstanceScale": {
      "GeometryNodeInputInstanceScale": {
        "inputs": [],
        "outputs": [
          "Scale: Vector"
        ],
        "description": "Retrieve the scale of each instance in the geometry"
      }
    },
    "GeometryNodeInputMaterial": {
      "GeometryNodeInputMaterial": {
        "inputs": [],
        "outputs": [
          "Material: Material"
        ],
        "description": "Output a single material"
      }
    },
    "GeometryNodeInputMaterialIndex": {
      "GeometryNodeInputMaterialIndex": {
        "inputs": [],
        "outputs": [
          "Material Index: Int"
        ],
        "description": "Retrieve the index of the material used for each element in the geometry's list of materials"
      }
    },
    "GeometryNodeInputMeshEdgeAngle": {
      "GeometryNodeInputMeshEdgeAngle": {
        "inputs": [],
        "outputs": [
          "Unsigned Angle: Float",
          "Signed Angle: Float"
        ],
        "description": "The angle between the normals of connected manifold faces"
      }
    },
    "GeometryNodeInputMeshEdgeNeighbors": {
      "GeometryNodeInputMeshEdgeNeighbors": {
        "inputs": [],
        "outputs": [
          "Face Count: Int"
        ],
        "description": "Retrieve the number of faces that use each edge as one of their sides"
      }
    },
    "GeometryNodeInputMeshEdgeVertices": {
      "GeometryNodeInputMeshEdgeVertices": {
        "inputs": [],
        "outputs": [
          "Vertex Index 1: Int",
          "Vertex Index 2: Int",
          "Position 1: Vector",
          "Position 2: Vector"
        ],
        "description": "Retrieve topology information relating to each edge of a mesh"
      }
    },
    "GeometryNodeInputMeshFaceArea": {
      "GeometryNodeInputMeshFaceArea": {
        "inputs": [],
        "outputs": [
          "Area: Float"
        ],
        "description": "Calculate the surface area of a mesh's faces"
      }
    },
    "GeometryNodeInputMeshFaceIsPlanar": {
      "GeometryNodeInputMeshFaceIsPlanar": {
        "inputs": [
          "Threshold: FloatDistance"
        ],
        "outputs": [
          "Planar: Bool"
        ],
        "description": "Retrieve whether all triangles in a face are on the same plane, i.e. whether they have the same normal"
      }
    },
    "GeometryNodeInputMeshFaceNeighbors": {
      "GeometryNodeInputMeshFaceNeighbors": {
        "inputs": [],
        "outputs": [
          "Vertex Count: Int",
          "Face Count: Int"
        ],
        "description": "Retrieve topology information relating to each face of a mesh"
      }
    },
    "GeometryNodeInputMeshIsland": {
      "GeometryNodeInputMeshIsland": {
        "inputs": [],
        "outputs": [
          "Island Index: Int",
          "Island Count: Int"
        ],
        "description": "Retrieve information about separate connected regions in a mesh"
      }
    },
    "GeometryNodeInputMeshVertexNeighbors": {
      "GeometryNodeInputMeshVertexNeighbors": {
        "inputs": [],
        "outputs": [
          "Vertex Count: Int",
          "Face Count: Int"
        ],
        "description": "Retrieve topology information relating to each vertex of a mesh"
      }
    },
    "GeometryNodeInputNamedAttribute": {
      "GeometryNodeInputNamedAttribute": {
        "inputs": [
          "Name: String"
        ],
        "outputs": [
          "Attribute: Float",
          "Exists: Bool"
        ],
        "description": "Retrieve the data of a specified attribute"
      }
    },
    "GeometryNodeInputNamedLayerSelection": {
      "GeometryNodeInputNamedLayerSelection": {
        "inputs": [
          "Name: String"
        ],
        "outputs": [
          "Selection: Bool"
        ],
        "description": "Output a selection of a Grease Pencil layer"
      }
    },
    "GeometryNodeInputNormal": {
      "GeometryNodeInputNormal": {
        "inputs": [],
        "outputs": [
          "Normal: Vector"
        ],
        "description": "Retrieve a unit length vector indicating the direction pointing away from the geometry at each element"
      }
    },
    "GeometryNodeInputObject": {
      "GeometryNodeInputObject": {
        "inputs": [],
        "outputs": [
          "Object: Object"
        ],
        "description": "Output a single object"
      }
    },
    "GeometryNodeInputPosition": {
      "GeometryNodeInputPosition": {
        "inputs": [],
        "outputs": [
          "Position: Vector"
        ],
        "description": "Retrieve a vector indicating the location of each element"
      }
    },
    "GeometryNodeInputRadius": {
      "GeometryNodeInputRadius": {
        "inputs": [],
        "outputs": [
          "Radius: Float"
        ],
        "description": "Retrieve the radius at each point on curve or point cloud geometry"
      }
    },
    "GeometryNodeInputSceneTime": {
      "GeometryNodeInputSceneTime": {
        "inputs": [],
        "outputs": [
          "Seconds: Float",
          "Frame: Float"
        ],
        "description": "Retrieve the current time in the scene's animation in units of seconds or frames"
      }
    },
    "GeometryNodeInputShadeSmooth": {
      "GeometryNodeInputShadeSmooth": {
        "inputs": [],
        "outputs": [
          "Smooth: Bool"
        ],
        "description": "Retrieve whether each face is marked for smooth or sharp normals"
      }
    },
    "GeometryNodeInputShortestEdgePaths": {
      "GeometryNodeInputShortestEdgePaths": {
        "inputs": [
          "End Vertex: Bool",
          "Edge Cost: Float"
        ],
        "outputs": [
          "Next Vertex Index: Int",
          "Total Cost: Float"
        ],
        "description": "Find the shortest paths along mesh edges to selected end vertices, with customizable cost per edge"
      }
    },
    "GeometryNodeInputSplineCyclic": {
      "GeometryNodeInputSplineCyclic": {
        "inputs": [],
        "outputs": [
          "Cyclic: Bool"
        ],
        "description": "Retrieve whether each spline endpoint connects to the beginning"
      }
    },
    "GeometryNodeInputSplineResolution": {
      "GeometryNodeInputSplineResolution": {
        "inputs": [],
        "outputs": [
          "Resolution: Int"
        ],
        "description": "Retrieve the number of evaluated points that will be generated for every control point on curves"
      }
    },
    "GeometryNodeInputTangent": {
      "GeometryNodeInputTangent": {
        "inputs": [],
        "outputs": [
          "Tangent: Vector"
        ],
        "description": "Retrieve the direction of curves at each control point"
      }
    },
    "GeometryNodeInstanceOnPoints": {
      "GeometryNodeInstanceOnPoints": {
        "inputs": [
          "Points: Geometry",
          "Selection: Bool",
          "Instance: Geometry",
          "Pick Instance: Bool",
          "Instance Index: Int",
          "Rotation: Rotation",
          "Scale: VectorXYZ"
        ],
        "outputs": [
          "Instances: Geometry"
        ],
        "description": "Generate a reference to geometry at each of the input points, without duplicating its underlying data"
      }
    },
    "GeometryNodeInstanceTransform": {
      "GeometryNodeInstanceTransform": {
        "inputs": [],
        "outputs": [
          "Transform: Matrix"
        ],
        "description": "Retrieve the full transformation of each instance in the geometry"
      }
    },
    "GeometryNodeInstancesToPoints": {
      "GeometryNodeInstancesToPoints": {
        "inputs": [
          "Instances: Geometry",
          "Selection: Bool",
          "Position: Vector",
          "Radius: FloatDistance"
        ],
        "outputs": [
          "Points: Geometry"
        ],
        "description": "Generate points at the origins of instances.\nNote: Nested instances are not affected by this node"
      }
    },
    "GeometryNodeInterpolateCurves": {
      "GeometryNodeInterpolateCurves": {
        "inputs": [
          "Guide Curves: Geometry",
          "Guide Up: Vector",
          "Guide Group ID: Int",
          "Points: Geometry",
          "Point Up: Vector",
          "Point Group ID: Int",
          "Max Neighbors: Int"
        ],
        "outputs": [
          "Curves: Geometry",
          "Closest Index: Int",
          "Closest Weight: Float"
        ],
        "description": "Generate new curves on points by interpolating between existing curves"
      }
    },
    "GeometryNodeIsViewport": {
      "GeometryNodeIsViewport": {
        "inputs": [],
        "outputs": [
          "Is Viewport: Bool"
        ],
        "description": "Retrieve whether the nodes are being evaluated for the viewport rather than the final render"
      }
    },
    "GeometryNodeJoinGeometry": {
      "GeometryNodeJoinGeometry": {
        "inputs": [
          "Geometry: Geometry"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Merge separately generated geometries into a single one"
      }
    },
    "GeometryNodeMaterialSelection": {
      "GeometryNodeMaterialSelection": {
        "inputs": [
          "Material: Material"
        ],
        "outputs": [
          "Selection: Bool"
        ],
        "description": "Provide a selection of faces that use the specified material"
      }
    },
    "GeometryNodeMenuSwitch": {
      "GeometryNodeMenuSwitch": {
        "inputs": [
          "Menu: Menu",
          "A: Geometry",
          "B: Geometry",
          ": Virtual"
        ],
        "outputs": [
          "Output: Geometry"
        ],
        "description": "Select from multiple inputs by name"
      }
    },
    "GeometryNodeMergeByDistance": {
      "GeometryNodeMergeByDistance": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Distance: FloatDistance"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Merge vertices or points within a given distance"
      }
    },
    "GeometryNodeMergeLayers": {
      "GeometryNodeMergeLayers": {
        "inputs": [
          "Grease Pencil: Geometry",
          "Selection: Bool",
          "Group ID: Int"
        ],
        "outputs": [
          "Grease Pencil: Geometry"
        ],
        "description": "Join groups of Grease Pencil layers into one"
      }
    },
    "GeometryNodeMeshBoolean": {
      "GeometryNodeMeshBoolean": {
        "inputs": [
          "Mesh 1: Geometry",
          "Mesh 2: Geometry",
          "Self Intersection: Bool",
          "Hole Tolerant: Bool"
        ],
        "outputs": [
          "Mesh: Geometry",
          "Intersecting Edges: Bool"
        ],
        "description": "Cut, subtract, or join multiple mesh inputs"
      }
    },
    "GeometryNodeMeshCircle": {
      "GeometryNodeMeshCircle": {
        "inputs": [
          "Vertices: Int",
          "Radius: FloatDistance"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Generate a circular ring of edges"
      }
    },
    "GeometryNodeMeshCone": {
      "GeometryNodeMeshCone": {
        "inputs": [
          "Vertices: Int",
          "Side Segments: Int",
          "Fill Segments: Int",
          "Radius Top: FloatDistance",
          "Radius Bottom: FloatDistance",
          "Depth: FloatDistance"
        ],
        "outputs": [
          "Mesh: Geometry",
          "Top: Bool",
          "Bottom: Bool",
          "Side: Bool",
          "UV Map: Vector"
        ],
        "description": "Generate a cone mesh"
      }
    },
    "GeometryNodeMeshCube": {
      "GeometryNodeMeshCube": {
        "inputs": [
          "Size: VectorTranslation",
          "Vertices X: Int",
          "Vertices Y: Int",
          "Vertices Z: Int"
        ],
        "outputs": [
          "Mesh: Geometry",
          "UV Map: Vector"
        ],
        "description": "Generate a cuboid mesh with variable side lengths and subdivisions"
      }
    },
    "GeometryNodeMeshCylinder": {
      "GeometryNodeMeshCylinder": {
        "inputs": [
          "Vertices: Int",
          "Side Segments: Int",
          "Fill Segments: Int",
          "Radius: FloatDistance",
          "Depth: FloatDistance"
        ],
        "outputs": [
          "Mesh: Geometry",
          "Top: Bool",
          "Side: Bool",
          "Bottom: Bool",
          "UV Map: Vector"
        ],
        "description": "Generate a cylinder mesh"
      }
    },
    "GeometryNodeMeshFaceSetBoundaries": {
      "GeometryNodeMeshFaceSetBoundaries": {
        "inputs": [
          "Face Group ID: Int"
        ],
        "outputs": [
          "Boundary Edges: Bool"
        ],
        "description": "Find edges on the boundaries between groups of faces with the same ID value"
      }
    },
    "GeometryNodeMeshGrid": {
      "GeometryNodeMeshGrid": {
        "inputs": [
          "Size X: FloatDistance",
          "Size Y: FloatDistance",
          "Vertices X: Int",
          "Vertices Y: Int"
        ],
        "outputs": [
          "Mesh: Geometry",
          "UV Map: Vector"
        ],
        "description": "Generate a planar mesh on the XY plane"
      }
    },
    "GeometryNodeMeshIcoSphere": {
      "GeometryNodeMeshIcoSphere": {
        "inputs": [
          "Radius: FloatDistance",
          "Subdivisions: Int"
        ],
        "outputs": [
          "Mesh: Geometry",
          "UV Map: Vector"
        ],
        "description": "Generate a spherical mesh that consists of equally sized triangles"
      }
    },
    "GeometryNodeMeshLine": {
      "GeometryNodeMeshLine": {
        "inputs": [
          "Count: Int",
          "Resolution: FloatDistance",
          "Start Location: VectorTranslation",
          "Offset: VectorTranslation"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Generate vertices in a line and connect them with edges"
      }
    },
    "GeometryNodeMeshToCurve": {
      "GeometryNodeMeshToCurve": {
        "inputs": [
          "Mesh: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Generate a curve from a mesh"
      }
    },
    "GeometryNodeMeshToDensityGrid": {
      "GeometryNodeMeshToDensityGrid": {
        "inputs": [
          "Mesh: Geometry",
          "Density: Float",
          "Voxel Size: FloatDistance",
          "Gradient Width: FloatDistance"
        ],
        "outputs": [
          "Density Grid: Float"
        ],
        "description": "Create a filled volume grid from a mesh"
      }
    },
    "GeometryNodeMeshToPoints": {
      "GeometryNodeMeshToPoints": {
        "inputs": [
          "Mesh: Geometry",
          "Selection: Bool",
          "Position: Vector",
          "Radius: FloatDistance"
        ],
        "outputs": [
          "Points: Geometry"
        ],
        "description": "Generate a point cloud from a mesh's vertices"
      }
    },
    "GeometryNodeMeshToSDFGrid": {
      "GeometryNodeMeshToSDFGrid": {
        "inputs": [
          "Mesh: Geometry",
          "Voxel Size: FloatDistance",
          "Band Width: Int"
        ],
        "outputs": [
          "SDF Grid: Float"
        ],
        "description": "Create a signed distance volume grid from a mesh"
      }
    },
    "GeometryNodeMeshToVolume": {
      "GeometryNodeMeshToVolume": {
        "inputs": [
          "Mesh: Geometry",
          "Density: Float",
          "Voxel Size: FloatDistance",
          "Voxel Amount: Float",
          "Interior Band Width: FloatDistance"
        ],
        "outputs": [
          "Volume: Geometry"
        ],
        "description": "Create a fog volume with the shape of the input mesh's surface"
      }
    },
    "GeometryNodeMeshUVSphere": {
      "GeometryNodeMeshUVSphere": {
        "inputs": [
          "Segments: Int",
          "Rings: Int",
          "Radius: FloatDistance"
        ],
        "outputs": [
          "Mesh: Geometry",
          "UV Map: Vector"
        ],
        "description": "Generate a spherical mesh with quads, except for triangles at the top and bottom"
      }
    },
    "GeometryNodeObjectInfo": {
      "GeometryNodeObjectInfo": {
        "inputs": [
          "Object: Object",
          "As Instance: Bool"
        ],
        "outputs": [
          "Transform: Matrix",
          "Location: Vector",
          "Rotation: Rotation",
          "Scale: Vector",
          "Geometry: Geometry"
        ],
        "description": "Retrieve information from an object"
      }
    },
    "GeometryNodeOffsetCornerInFace": {
      "GeometryNodeOffsetCornerInFace": {
        "inputs": [
          "Corner Index: Int",
          "Offset: Int"
        ],
        "outputs": [
          "Corner Index: Int"
        ],
        "description": "Retrieve corners in the same face as another"
      }
    },
    "GeometryNodeOffsetPointInCurve": {
      "GeometryNodeOffsetPointInCurve": {
        "inputs": [
          "Point Index: Int",
          "Offset: Int"
        ],
        "outputs": [
          "Is Valid Offset: Bool",
          "Point Index: Int"
        ],
        "description": "Offset a control point index within its curve"
      }
    },
    "GeometryNodePoints": {
      "GeometryNodePoints": {
        "inputs": [
          "Count: Int",
          "Position: VectorTranslation",
          "Radius: FloatDistance"
        ],
        "outputs": [
          "Points: Geometry"
        ],
        "description": "Generate a point cloud with positions and radii defined by fields"
      }
    },
    "GeometryNodePointsOfCurve": {
      "GeometryNodePointsOfCurve": {
        "inputs": [
          "Curve Index: Int",
          "Weights: Float",
          "Sort Index: Int"
        ],
        "outputs": [
          "Point Index: Int",
          "Total: Int"
        ],
        "description": "Retrieve a point index within a curve"
      }
    },
    "GeometryNodePointsToCurves": {
      "GeometryNodePointsToCurves": {
        "inputs": [
          "Points: Geometry",
          "Curve Group ID: Int",
          "Weight: Float"
        ],
        "outputs": [
          "Curves: Geometry"
        ],
        "description": "Split all points to curve by its group ID and reorder by weight"
      }
    },
    "GeometryNodePointsToSDFGrid": {
      "GeometryNodePointsToSDFGrid": {
        "inputs": [
          "Points: Geometry",
          "Radius: FloatDistance",
          "Voxel Size: FloatDistance"
        ],
        "outputs": [
          "SDF Grid: Float"
        ],
        "description": "Create a signed distance volume grid from points"
      }
    },
    "GeometryNodePointsToVertices": {
      "GeometryNodePointsToVertices": {
        "inputs": [
          "Points: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Generate a mesh vertex for each point cloud point"
      }
    },
    "GeometryNodePointsToVolume": {
      "GeometryNodePointsToVolume": {
        "inputs": [
          "Points: Geometry",
          "Density: Float",
          "Voxel Size: FloatDistance",
          "Voxel Amount: Float",
          "Radius: FloatDistance"
        ],
        "outputs": [
          "Volume: Geometry"
        ],
        "description": "Generate a fog volume sphere around every point"
      }
    },
    "GeometryNodeProximity": {
      "GeometryNodeProximity": {
        "inputs": [
          "Geometry: Geometry",
          "Group ID: Int",
          "Sample Position: Vector",
          "Sample Group ID: Int"
        ],
        "outputs": [
          "Position: Vector",
          "Distance: Float",
          "Is Valid: Bool"
        ],
        "description": "Compute the closest location on the target geometry"
      }
    },
    "GeometryNodeRaycast": {
      "GeometryNodeRaycast": {
        "inputs": [
          "Target Geometry: Geometry",
          "Attribute: Float",
          "Source Position: Vector",
          "Ray Direction: Vector",
          "Ray Length: FloatDistance"
        ],
        "outputs": [
          "Is Hit: Bool",
          "Hit Position: Vector",
          "Hit Normal: Vector",
          "Hit Distance: Float",
          "Attribute: Float"
        ],
        "description": "Cast rays from the context geometry onto a target geometry, and retrieve information from each hit point"
      }
    },
    "GeometryNodeRealizeInstances": {
      "GeometryNodeRealizeInstances": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Realize All: Bool",
          "Depth: Int"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Convert instances into real geometry data"
      }
    },
    "GeometryNodeRemoveAttribute": {
      "GeometryNodeRemoveAttribute": {
        "inputs": [
          "Geometry: Geometry",
          "Name: String"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Delete an attribute with a specified name from a geometry. Typically used to optimize performance"
      }
    },
    "GeometryNodeRepeatInput": {
      "GeometryNodeRepeatInput": {
        "inputs": [
          "Iterations: Int",
          ": Virtual"
        ],
        "outputs": [
          "Iteration: Int",
          ": Virtual"
        ],
        "description": ""
      }
    },
    "GeometryNodeRepeatOutput": {
      "GeometryNodeRepeatOutput": {
        "inputs": [
          "Geometry: Geometry",
          ": Virtual"
        ],
        "outputs": [
          "Geometry: Geometry",
          ": Virtual"
        ],
        "description": ""
      }
    },
    "GeometryNodeReplaceMaterial": {
      "GeometryNodeReplaceMaterial": {
        "inputs": [
          "Geometry: Geometry",
          "Old: Material",
          "New: Material"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Swap one material with another"
      }
    },
    "GeometryNodeResampleCurve": {
      "GeometryNodeResampleCurve": {
        "inputs": [
          "Curve: Geometry",
          "Selection: Bool",
          "Count: Int",
          "Length: FloatDistance"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Generate a poly spline for each input spline"
      }
    },
    "GeometryNodeReverseCurve": {
      "GeometryNodeReverseCurve": {
        "inputs": [
          "Curve: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Change the direction of curves by swapping their start and end data"
      }
    },
    "GeometryNodeRotateInstances": {
      "GeometryNodeRotateInstances": {
        "inputs": [
          "Instances: Geometry",
          "Selection: Bool",
          "Rotation: Rotation",
          "Pivot Point: VectorTranslation",
          "Local Space: Bool"
        ],
        "outputs": [
          "Instances: Geometry"
        ],
        "description": "Rotate geometry instances in local or global space"
      }
    },
    "GeometryNodeSDFGridBoolean": {
      "GeometryNodeSDFGridBoolean": {
        "inputs": [
          "Grid 1: Float",
          "Grid 2: Float"
        ],
        "outputs": [
          "Grid: Float"
        ],
        "description": "Cut, subtract, or join multiple SDF volume grid inputs"
      }
    },
    "GeometryNodeSampleCurve": {
      "GeometryNodeSampleCurve": {
        "inputs": [
          "Curves: Geometry",
          "Value: Float",
          "Factor: FloatFactor",
          "Length: FloatDistance",
          "Curve Index: Int"
        ],
        "outputs": [
          "Value: Float",
          "Position: Vector",
          "Tangent: Vector",
          "Normal: Vector"
        ],
        "description": "Retrieve data from a point on a curve at a certain distance from its start"
      }
    },
    "GeometryNodeSampleGrid": {
      "GeometryNodeSampleGrid": {
        "inputs": [
          "Grid: Float",
          "Position: Vector"
        ],
        "outputs": [
          "Value: Float"
        ],
        "description": ""
      }
    },
    "GeometryNodeSampleGridIndex": {
      "GeometryNodeSampleGridIndex": {
        "inputs": [
          "Grid: Float",
          "X: Int",
          "Y: Int",
          "Z: Int"
        ],
        "outputs": [
          "Value: Float"
        ],
        "description": "Retrieve volume grid values at specific voxels"
      }
    },
    "GeometryNodeSampleIndex": {
      "GeometryNodeSampleIndex": {
        "inputs": [
          "Geometry: Geometry",
          "Value: Float",
          "Index: Int"
        ],
        "outputs": [
          "Value: Float"
        ],
        "description": "Retrieve values from specific geometry elements"
      }
    },
    "GeometryNodeSampleNearest": {
      "GeometryNodeSampleNearest": {
        "inputs": [
          "Geometry: Geometry",
          "Sample Position: Vector"
        ],
        "outputs": [
          "Index: Int"
        ],
        "description": "Find the element of a geometry closest to a position. Similar to the \"Index of Nearest\" node"
      }
    },
    "GeometryNodeSampleNearestSurface": {
      "GeometryNodeSampleNearestSurface": {
        "inputs": [
          "Mesh: Geometry",
          "Value: Float",
          "Group ID: Int",
          "Sample Position: Vector",
          "Sample Group ID: Int"
        ],
        "outputs": [
          "Value: Float",
          "Is Valid: Bool"
        ],
        "description": "Calculate the interpolated value of a mesh attribute on the closest point of its surface"
      }
    },
    "GeometryNodeSampleUVSurface": {
      "GeometryNodeSampleUVSurface": {
        "inputs": [
          "Mesh: Geometry",
          "Value: Float",
          "UV Map: Vector",
          "Sample UV: Vector"
        ],
        "outputs": [
          "Value: Float",
          "Is Valid: Bool"
        ],
        "description": "Calculate the interpolated values of a mesh attribute at a UV coordinate"
      }
    },
    "GeometryNodeScaleElements": {
      "GeometryNodeScaleElements": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Scale: Float",
          "Center: VectorTranslation",
          "Axis: Vector"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Scale groups of connected edges and faces"
      }
    },
    "GeometryNodeScaleInstances": {
      "GeometryNodeScaleInstances": {
        "inputs": [
          "Instances: Geometry",
          "Selection: Bool",
          "Scale: VectorXYZ",
          "Center: VectorTranslation",
          "Local Space: Bool"
        ],
        "outputs": [
          "Instances: Geometry"
        ],
        "description": "Scale geometry instances in local or global space"
      }
    },
    "GeometryNodeSelfObject": {
      "GeometryNodeSelfObject": {
        "inputs": [],
        "outputs": [
          "Self Object: Object"
        ],
        "description": "Retrieve the object that contains the geometry nodes modifier currently being executed"
      }
    },
    "GeometryNodeSeparateComponents": {
      "GeometryNodeSeparateComponents": {
        "inputs": [
          "Geometry: Geometry"
        ],
        "outputs": [
          "Mesh: Geometry",
          "Curve: Geometry",
          "Grease Pencil: Geometry",
          "Point Cloud: Geometry",
          "Volume: Geometry",
          "Instances: Geometry"
        ],
        "description": "Split a geometry into a separate output for each type of data in the geometry"
      }
    },
    "GeometryNodeSeparateGeometry": {
      "GeometryNodeSeparateGeometry": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Selection: Geometry",
          "Inverted: Geometry"
        ],
        "description": "Split a geometry into two geometry outputs based on a selection"
      }
    },
    "GeometryNodeSetCurveHandlePositions": {
      "GeometryNodeSetCurveHandlePositions": {
        "inputs": [
          "Curve: Geometry",
          "Selection: Bool",
          "Position: Vector",
          "Offset: Vector"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Set the positions for the handles of B\u00e9zier curves"
      }
    },
    "GeometryNodeSetCurveNormal": {
      "GeometryNodeSetCurveNormal": {
        "inputs": [
          "Curve: Geometry",
          "Selection: Bool",
          "Normal: VectorXYZ"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Set the evaluation mode for curve normals"
      }
    },
    "GeometryNodeSetCurveRadius": {
      "GeometryNodeSetCurveRadius": {
        "inputs": [
          "Curve: Geometry",
          "Selection: Bool",
          "Radius: FloatDistance"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Set the radius of the curve at each control point"
      }
    },
    "GeometryNodeSetCurveTilt": {
      "GeometryNodeSetCurveTilt": {
        "inputs": [
          "Curve: Geometry",
          "Selection: Bool",
          "Tilt: FloatAngle"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Set the tilt angle at each curve control point"
      }
    },
    "GeometryNodeSetGeometryName": {
      "GeometryNodeSetGeometryName": {
        "inputs": [
          "Geometry: Geometry",
          "Name: String"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Set the name of a geometry for easier debugging"
      }
    },
    "GeometryNodeSetID": {
      "GeometryNodeSetID": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "ID: Int"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Set the id attribute on the input geometry, mainly used internally for randomizing"
      }
    },
    "GeometryNodeSetInstanceTransform": {
      "GeometryNodeSetInstanceTransform": {
        "inputs": [
          "Instances: Geometry",
          "Selection: Bool",
          "Transform: Matrix"
        ],
        "outputs": [
          "Instances: Geometry"
        ],
        "description": "Set the transformation matrix of every instance"
      }
    },
    "GeometryNodeSetMaterial": {
      "GeometryNodeSetMaterial": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Material: Material"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Assign a material to geometry elements"
      }
    },
    "GeometryNodeSetMaterialIndex": {
      "GeometryNodeSetMaterialIndex": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Material Index: Int"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Set the material index for each selected geometry element"
      }
    },
    "GeometryNodeSetPointRadius": {
      "GeometryNodeSetPointRadius": {
        "inputs": [
          "Points: Geometry",
          "Selection: Bool",
          "Radius: FloatDistance"
        ],
        "outputs": [
          "Points: Geometry"
        ],
        "description": "Set the display size of point cloud points"
      }
    },
    "GeometryNodeSetPosition": {
      "GeometryNodeSetPosition": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Position: Vector",
          "Offset: VectorTranslation"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Set the location of each point"
      }
    },
    "GeometryNodeSetShadeSmooth": {
      "GeometryNodeSetShadeSmooth": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Shade Smooth: Bool"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Control the smoothness of mesh normals around each face by changing the \"shade smooth\" attribute"
      }
    },
    "GeometryNodeSetSplineCyclic": {
      "GeometryNodeSetSplineCyclic": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Cyclic: Bool"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Control whether each spline loops back on itself by changing the \"cyclic\" attribute"
      }
    },
    "GeometryNodeSetSplineResolution": {
      "GeometryNodeSetSplineResolution": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Resolution: Int"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Control how many evaluated points should be generated on every curve segment"
      }
    },
    "GeometryNodeSimulationInput": {
      "GeometryNodeSimulationInput": {
        "inputs": [],
        "outputs": [
          "Delta Time: Float"
        ],
        "description": "Input data for the simulation zone"
      }
    },
    "GeometryNodeSimulationOutput": {
      "GeometryNodeSimulationOutput": {
        "inputs": [
          "Skip: Bool",
          "Geometry: Geometry",
          ": Virtual"
        ],
        "outputs": [
          "Geometry: Geometry",
          ": Virtual"
        ],
        "description": "Output data from the simulation zone"
      }
    },
    "GeometryNodeSortElements": {
      "GeometryNodeSortElements": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Group ID: Int",
          "Sort Weight: Float"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Rearrange geometry elements, changing their indices"
      }
    },
    "GeometryNodeSplineLength": {
      "GeometryNodeSplineLength": {
        "inputs": [],
        "outputs": [
          "Length: Float",
          "Point Count: Int"
        ],
        "description": "Retrieve the total length of each spline, as a distance or as a number of points"
      }
    },
    "GeometryNodeSplineParameter": {
      "GeometryNodeSplineParameter": {
        "inputs": [],
        "outputs": [
          "Factor: Float",
          "Length: Float",
          "Index: Int"
        ],
        "description": "Retrieve how far along each spline a control point is"
      }
    },
    "GeometryNodeSplitEdges": {
      "GeometryNodeSplitEdges": {
        "inputs": [
          "Mesh: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Duplicate mesh edges and break connections with the surrounding faces"
      }
    },
    "GeometryNodeSplitToInstances": {
      "GeometryNodeSplitToInstances": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Group ID: Int"
        ],
        "outputs": [
          "Instances: Geometry",
          "Group ID: Int"
        ],
        "description": "Create separate geometries containing the elements from the same group"
      }
    },
    "GeometryNodeStoreNamedAttribute": {
      "GeometryNodeStoreNamedAttribute": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool",
          "Name: String",
          "Value: Float"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Store the result of a field on a geometry as an attribute with the specified name"
      }
    },
    "GeometryNodeStoreNamedGrid": {
      "GeometryNodeStoreNamedGrid": {
        "inputs": [
          "Volume: Geometry",
          "Name: String",
          "Grid: Float"
        ],
        "outputs": [
          "Volume: Geometry"
        ],
        "description": "Store grid data in a volume geometry with the specified name"
      }
    },
    "GeometryNodeStringJoin": {
      "GeometryNodeStringJoin": {
        "inputs": [
          "Delimiter: String",
          "Strings: String"
        ],
        "outputs": [
          "String: String"
        ],
        "description": "Combine any number of input strings"
      }
    },
    "GeometryNodeStringToCurves": {
      "GeometryNodeStringToCurves": {
        "inputs": [
          "String: String",
          "Size: FloatDistance",
          "Character Spacing: Float",
          "Word Spacing: Float",
          "Line Spacing: Float",
          "Text Box Width: FloatDistance",
          "Text Box Height: FloatDistance"
        ],
        "outputs": [
          "Curve Instances: Geometry",
          "Remainder: String",
          "Line: Int",
          "Pivot Point: Vector"
        ],
        "description": "Generate a paragraph of text with a specific font, using a curve instance to store each character"
      }
    },
    "GeometryNodeSubdivideCurve": {
      "GeometryNodeSubdivideCurve": {
        "inputs": [
          "Curve: Geometry",
          "Cuts: Int"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Dividing each curve segment into a specified number of pieces"
      }
    },
    "GeometryNodeSubdivideMesh": {
      "GeometryNodeSubdivideMesh": {
        "inputs": [
          "Mesh: Geometry",
          "Level: Int"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Divide mesh faces into smaller ones without changing the shape or volume, using linear interpolation to place the new vertices"
      }
    },
    "GeometryNodeSubdivisionSurface": {
      "GeometryNodeSubdivisionSurface": {
        "inputs": [
          "Mesh: Geometry",
          "Level: Int",
          "Edge Crease: FloatFactor",
          "Vertex Crease: FloatFactor",
          "Limit Surface: Bool"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Divide mesh faces to form a smooth surface, using the Catmull-Clark subdivision method"
      }
    },
    "GeometryNodeSwitch": {
      "GeometryNodeSwitch": {
        "inputs": [
          "Switch: Bool",
          "False: Geometry",
          "True: Geometry"
        ],
        "outputs": [
          "Output: Geometry"
        ],
        "description": "Switch between two inputs"
      }
    },
    "GeometryNodeTool3DCursor": {
      "GeometryNodeTool3DCursor": {
        "inputs": [],
        "outputs": [
          "Location: VectorTranslation",
          "Rotation: Rotation"
        ],
        "description": "The scene's 3D cursor location and rotation"
      }
    },
    "GeometryNodeToolActiveElement": {
      "GeometryNodeToolActiveElement": {
        "inputs": [],
        "outputs": [
          "Index: Int",
          "Exists: Bool"
        ],
        "description": "Active element indices of the edited geometry, for tool execution"
      }
    },
    "GeometryNodeToolFaceSet": {
      "GeometryNodeToolFaceSet": {
        "inputs": [],
        "outputs": [
          "Face Set: Int",
          "Exists: Bool"
        ],
        "description": "Each face's sculpt face set value"
      }
    },
    "GeometryNodeToolMousePosition": {
      "GeometryNodeToolMousePosition": {
        "inputs": [],
        "outputs": [
          "Mouse X: Int",
          "Mouse Y: Int",
          "Region Width: Int",
          "Region Height: Int"
        ],
        "description": "Retrieve the position of the mouse cursor"
      }
    },
    "GeometryNodeToolSelection": {
      "GeometryNodeToolSelection": {
        "inputs": [],
        "outputs": [
          "Boolean: Bool",
          "Float: Float"
        ],
        "description": "User selection of the edited geometry, for tool execution"
      }
    },
    "GeometryNodeToolSetFaceSet": {
      "GeometryNodeToolSetFaceSet": {
        "inputs": [
          "Mesh: Geometry",
          "Selection: Bool",
          "Face Set: Int"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Set sculpt face set values for faces"
      }
    },
    "GeometryNodeToolSetSelection": {
      "GeometryNodeToolSetSelection": {
        "inputs": [
          "Geometry: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Set selection of the edited geometry, for tool execution"
      }
    },
    "GeometryNodeTransform": {
      "GeometryNodeTransform": {
        "inputs": [
          "Geometry: Geometry",
          "Translation: VectorTranslation",
          "Rotation: Rotation",
          "Scale: VectorXYZ",
          "Transform: Matrix"
        ],
        "outputs": [
          "Geometry: Geometry"
        ],
        "description": "Translate, rotate or scale the geometry"
      }
    },
    "GeometryNodeTranslateInstances": {
      "GeometryNodeTranslateInstances": {
        "inputs": [
          "Instances: Geometry",
          "Selection: Bool",
          "Translation: VectorTranslation",
          "Local Space: Bool"
        ],
        "outputs": [
          "Instances: Geometry"
        ],
        "description": "Move top-level geometry instances in local or global space"
      }
    },
    "GeometryNodeTriangulate": {
      "GeometryNodeTriangulate": {
        "inputs": [
          "Mesh: Geometry",
          "Selection: Bool"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Convert all faces in a mesh to triangular faces"
      }
    },
    "GeometryNodeTrimCurve": {
      "GeometryNodeTrimCurve": {
        "inputs": [
          "Curve: Geometry",
          "Selection: Bool",
          "Start: FloatFactor",
          "End: FloatFactor",
          "Start: FloatDistance",
          "End: FloatDistance"
        ],
        "outputs": [
          "Curve: Geometry"
        ],
        "description": "Shorten curves by removing portions at the start or end"
      }
    },
    "GeometryNodeUVPackIslands": {
      "GeometryNodeUVPackIslands": {
        "inputs": [
          "UV: Vector",
          "Selection: Bool",
          "Margin: Float",
          "Rotate: Bool"
        ],
        "outputs": [
          "UV: Vector"
        ],
        "description": "Scale islands of a UV map and move them so they fill the UV space as much as possible"
      }
    },
    "GeometryNodeUVUnwrap": {
      "GeometryNodeUVUnwrap": {
        "inputs": [
          "Selection: Bool",
          "Seam: Bool",
          "Margin: Float",
          "Fill Holes: Bool"
        ],
        "outputs": [
          "UV: Vector"
        ],
        "description": "Generate a UV map based on seam edges"
      }
    },
    "GeometryNodeVertexOfCorner": {
      "GeometryNodeVertexOfCorner": {
        "inputs": [
          "Corner Index: Int"
        ],
        "outputs": [
          "Vertex Index: Int"
        ],
        "description": "Retrieve the vertex each face corner is attached to"
      }
    },
    "GeometryNodeViewer": {
      "GeometryNodeViewer": {
        "inputs": [
          "Geometry: Geometry",
          "Value: Float"
        ],
        "outputs": [],
        "description": "Display the input data in the Spreadsheet Editor"
      }
    },
    "GeometryNodeViewportTransform": {
      "GeometryNodeViewportTransform": {
        "inputs": [],
        "outputs": [
          "Projection: Matrix",
          "View: Matrix",
          "Is Orthographic: Bool"
        ],
        "description": "Retrieve the view direction and location of the 3D viewport"
      }
    },
    "GeometryNodeVolumeCube": {
      "GeometryNodeVolumeCube": {
        "inputs": [
          "Density: Float",
          "Background: Float",
          "Min: Vector",
          "Max: Vector",
          "Resolution X: Int",
          "Resolution Y: Int",
          "Resolution Z: Int"
        ],
        "outputs": [
          "Volume: Geometry"
        ],
        "description": "Generate a dense volume with a field that controls the density at each grid voxel based on its position"
      }
    },
    "GeometryNodeVolumeToMesh": {
      "GeometryNodeVolumeToMesh": {
        "inputs": [
          "Volume: Geometry",
          "Voxel Size: FloatDistance",
          "Voxel Amount: Float",
          "Threshold: Float",
          "Adaptivity: FloatFactor"
        ],
        "outputs": [
          "Mesh: Geometry"
        ],
        "description": "Generate a mesh on the \"surface\" of a volume"
      }
    },
    "FunctionNodeAlignEulerToVector": {
      "FunctionNodeAlignEulerToVector": {
        "inputs": [
          "Rotation: VectorEuler",
          "Factor: FloatFactor",
          "Vector: Vector"
        ],
        "outputs": [
          "Rotation: VectorEuler"
        ],
        "description": ""
      }
    },
    "FunctionNodeAlignRotationToVector": {
      "FunctionNodeAlignRotationToVector": {
        "inputs": [
          "Rotation: Rotation",
          "Factor: FloatFactor",
          "Vector: VectorXYZ"
        ],
        "outputs": [
          "Rotation: Rotation"
        ],
        "description": ""
      }
    },
    "FunctionNodeAxesToRotation": {
      "FunctionNodeAxesToRotation": {
        "inputs": [
          "Primary Axis: Vector",
          "Secondary Axis: Vector"
        ],
        "outputs": [
          "Rotation: Rotation"
        ],
        "description": "Create a rotation from a primary and (ideally orthogonal) secondary axis"
      }
    },
    "FunctionNodeAxisAngleToRotation": {
      "FunctionNodeAxisAngleToRotation": {
        "inputs": [
          "Axis: Vector",
          "Angle: FloatAngle"
        ],
        "outputs": [
          "Rotation: Rotation"
        ],
        "description": ""
      }
    },
    "FunctionNodeBooleanMath": {
      "FunctionNodeBooleanMath": {
        "inputs": [
          "Boolean: Bool",
          "Boolean: Bool"
        ],
        "outputs": [
          "Boolean: Bool"
        ],
        "description": ""
      }
    },
    "FunctionNodeCombineColor": {
      "FunctionNodeCombineColor": {
        "inputs": [
          "Red: FloatFactor",
          "Green: FloatFactor",
          "Blue: FloatFactor",
          "Alpha: FloatFactor"
        ],
        "outputs": [
          "Color: Color"
        ],
        "description": ""
      }
    },
    "FunctionNodeCombineMatrix": {
      "FunctionNodeCombineMatrix": {
        "inputs": [
          "Column 1 Row 1: Float",
          "Column 1 Row 2: Float",
          "Column 1 Row 3: Float",
          "Column 1 Row 4: Float",
          "Column 2 Row 1: Float",
          "Column 2 Row 2: Float",
          "Column 2 Row 3: Float",
          "Column 2 Row 4: Float",
          "Column 3 Row 1: Float",
          "Column 3 Row 2: Float",
          "Column 3 Row 3: Float",
          "Column 3 Row 4: Float",
          "Column 4 Row 1: Float",
          "Column 4 Row 2: Float",
          "Column 4 Row 3: Float",
          "Column 4 Row 4: Float"
        ],
        "outputs": [
          "Matrix: Matrix"
        ],
        "description": "Construct a 4x4 matrix from its individual values"
      }
    },
    "FunctionNodeCombineTransform": {
      "FunctionNodeCombineTransform": {
        "inputs": [
          "Translation: VectorTranslation",
          "Rotation: Rotation",
          "Scale: VectorXYZ"
        ],
        "outputs": [
          "Transform: Matrix"
        ],
        "description": ""
      }
    },
    "FunctionNodeCompare": {
      "FunctionNodeCompare": {
        "inputs": [
          "A: Float",
          "B: Float",
          "A: Int",
          "B: Int",
          "A: Vector",
          "B: Vector",
          "A: Color",
          "B: Color",
          "A: String",
          "B: String",
          "C: Float",
          "Angle: FloatAngle",
          "Epsilon: Float"
        ],
        "outputs": [
          "Result: Bool"
        ],
        "description": ""
      }
    },
    "FunctionNodeEulerToRotation": {
      "FunctionNodeEulerToRotation": {
        "inputs": [
          "Euler: VectorEuler"
        ],
        "outputs": [
          "Rotation: Rotation"
        ],
        "description": ""
      }
    },
    "FunctionNodeFindInString": {
      "FunctionNodeFindInString": {
        "inputs": [
          "String: String",
          "Search: String"
        ],
        "outputs": [
          "First Found: Int",
          "Count: Int"
        ],
        "description": ""
      }
    },
    "FunctionNodeFloatToInt": {
      "FunctionNodeFloatToInt": {
        "inputs": [
          "Float: Float"
        ],
        "outputs": [
          "Integer: Int"
        ],
        "description": ""
      }
    },
    "FunctionNodeHashValue": {
      "FunctionNodeHashValue": {
        "inputs": [
          "Value: Int",
          "Seed: Int"
        ],
        "outputs": [
          "Hash: Int"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputBool": {
      "FunctionNodeInputBool": {
        "inputs": [
          "Boolean: Bool"
        ],
        "outputs": [
          "Boolean: Bool"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputColor": {
      "FunctionNodeInputColor": {
        "inputs": [
          "Color: Color"
        ],
        "outputs": [
          "Color: Color"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputInt": {
      "FunctionNodeInputInt": {
        "inputs": [
          "Integer: Int"
        ],
        "outputs": [
          "Integer: Int"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputRotation": {
      "FunctionNodeInputRotation": {
        "inputs": [
          "Rotation: Rotation"
        ],
        "outputs": [
          "Rotation: Rotation"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputString": {
      "FunctionNodeInputString": {
        "inputs": [
          "String: String"
        ],
        "outputs": [
          "String: String"
        ],
        "description": ""
      }
    },
    "FunctionNodeInputVector": {
      "FunctionNodeInputVector": {
        "inputs": [
          "Vector: Vector"
        ],
        "outputs": [
          "Vector: Vector"
        ],
        "description": ""
      }
    },
    "FunctionNodeIntegerMath": {
      "FunctionNodeIntegerMath": {
        "inputs": [
          "Value: Int",
          "Value: Int",
          "Value: Int"
        ],
        "outputs": [
          "Value: Int"
        ],
        "description": ""
      }
    },
    "FunctionNodeInvertMatrix": {
      "FunctionNodeInvertMatrix": {
        "inputs": [
          "Matrix: Matrix"
        ],
        "outputs": [
          "Matrix: Matrix",
          "Invertible: Bool"
        ],
        "description": ""
      }
    },
    "FunctionNodeInvertRotation": {
      "FunctionNodeInvertRotation": {
        "inputs": [
          "Rotation: Rotation"
        ],
        "outputs": [
          "Rotation: Rotation"
        ],
        "description": ""
      }
    },
    "FunctionNodeMatrixDeterminant": {
      "FunctionNodeMatrixDeterminant": {
        "inputs": [
          "Matrix: Matrix"
        ],
        "outputs": [
          "Determinant: Float"
        ],
        "description": ""
      }
    },
    "FunctionNodeMatrixMultiply": {
      "FunctionNodeMatrixMultiply": {
        "inputs": [
          "Matrix: Matrix",
          "Matrix: Matrix"
        ],
        "outputs": [
          "Matrix: Matrix"
        ],
        "description": ""
      }
    },
    "FunctionNodeProjectPoint": {
      "FunctionNodeProjectPoint": {
        "inputs": [
          "Vector: VectorXYZ",
          "Transform: Matrix"
        ],
        "outputs": [
          "Vector: VectorXYZ"
        ],
        "description": "Project a point using a matrix, using location, rotation, scale, and perspective divide"
      }
    },
    "FunctionNodeQuaternionToRotation": {
      "FunctionNodeQuaternionToRotation": {
        "inputs": [
          "W: Float",
          "X: Float",
          "Y: Float",
          "Z: Float"
        ],
        "outputs": [
          "Rotation: Rotation"
        ],
        "description": ""
      }
    },
    "FunctionNodeRandomValue": {
      "FunctionNodeRandomValue": {
        "inputs": [
          "Min: Vector",
          "Max: Vector",
          "Min: Float",
          "Max: Float",
          "Min: Int",
          "Max: Int",
          "Probability: FloatFactor",
          "ID: Int",
          "Seed: Int"
        ],
        "outputs": [
          "Value: Vector",
          "Value: Float",
          "Value: Int",
          "Value: Bool"
        ],
        "description": ""
      }
    },
    "FunctionNodeReplaceString": {
      "FunctionNodeReplaceString": {
        "inputs": [
          "String: String",
          "Find: String",
          "Replace: String"
        ],
        "outputs": [
          "String: String"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotateEuler": {
      "FunctionNodeRotateEuler": {
        "inputs": [
          "Rotation: VectorEuler",
          "Rotate By: VectorEuler",
          "Axis: VectorXYZ",
          "Angle: FloatAngle"
        ],
        "outputs": [
          "Rotation: Vector"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotateRotation": {
      "FunctionNodeRotateRotation": {
        "inputs": [
          "Rotation: Rotation",
          "Rotate By: Rotation"
        ],
        "outputs": [
          "Rotation: Rotation"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotateVector": {
      "FunctionNodeRotateVector": {
        "inputs": [
          "Vector: Vector",
          "Rotation: Rotation"
        ],
        "outputs": [
          "Vector: Vector"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotationToAxisAngle": {
      "FunctionNodeRotationToAxisAngle": {
        "inputs": [
          "Rotation: Rotation"
        ],
        "outputs": [
          "Axis: Vector",
          "Angle: FloatAngle"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotationToEuler": {
      "FunctionNodeRotationToEuler": {
        "inputs": [
          "Rotation: Rotation"
        ],
        "outputs": [
          "Euler: VectorEuler"
        ],
        "description": ""
      }
    },
    "FunctionNodeRotationToQuaternion": {
      "FunctionNodeRotationToQuaternion": {
        "inputs": [
          "Rotation: Rotation"
        ],
        "outputs": [
          "W: Float",
          "X: Float",
          "Y: Float",
          "Z: Float"
        ],
        "description": ""
      }
    },
    "FunctionNodeSeparateColor": {
      "FunctionNodeSeparateColor": {
        "inputs": [
          "Color: Color"
        ],
        "outputs": [
          "Red: Float",
          "Green: Float",
          "Blue: Float",
          "Alpha: Float"
        ],
        "description": ""
      }
    },
    "FunctionNodeSeparateMatrix": {
      "FunctionNodeSeparateMatrix": {
        "inputs": [
          "Matrix: Matrix"
        ],
        "outputs": [
          "Column 1 Row 1: Float",
          "Column 1 Row 2: Float",
          "Column 1 Row 3: Float",
          "Column 1 Row 4: Float",
          "Column 2 Row 1: Float",
          "Column 2 Row 2: Float",
          "Column 2 Row 3: Float",
          "Column 2 Row 4: Float",
          "Column 3 Row 1: Float",
          "Column 3 Row 2: Float",
          "Column 3 Row 3: Float",
          "Column 3 Row 4: Float",
          "Column 4 Row 1: Float",
          "Column 4 Row 2: Float",
          "Column 4 Row 3: Float",
          "Column 4 Row 4: Float"
        ],
        "description": "Split a 4x4 matrix into its individual values"
      }
    },
    "FunctionNodeSeparateTransform": {
      "FunctionNodeSeparateTransform": {
        "inputs": [
          "Transform: Matrix"
        ],
        "outputs": [
          "Translation: VectorTranslation",
          "Rotation: Rotation",
          "Scale: VectorXYZ"
        ],
        "description": ""
      }
    },
    "FunctionNodeSliceString": {
      "FunctionNodeSliceString": {
        "inputs": [
          "String: String",
          "Position: Int",
          "Length: Int"
        ],
        "outputs": [
          "String: String"
        ],
        "description": ""
      }
    },
    "FunctionNodeStringLength": {
      "FunctionNodeStringLength": {
        "inputs": [
          "String: String"
        ],
        "outputs": [
          "Length: Int"
        ],
        "description": ""
      }
    },
    "FunctionNodeTransformDirection": {
      "FunctionNodeTransformDirection": {
        "inputs": [
          "Direction: VectorXYZ",
          "Transform: Matrix"
        ],
        "outputs": [
          "Direction: VectorXYZ"
        ],
        "description": ""
      }
    },
    "FunctionNodeTransformPoint": {
      "FunctionNodeTransformPoint": {
        "inputs": [
          "Vector: VectorXYZ",
          "Transform: Matrix"
        ],
        "outputs": [
          "Vector: VectorXYZ"
        ],
        "description": ""
      }
    },
    "FunctionNodeTransposeMatrix": {
      "FunctionNodeTransposeMatrix": {
        "inputs": [
          "Matrix: Matrix"
        ],
        "outputs": [
          "Matrix: Matrix"
        ],
        "description": ""
      }
    },
    "FunctionNodeValueToString": {
      "FunctionNodeValueToString": {
        "inputs": [
          "Value: Float",
          "Decimals: Int"
        ],
        "outputs": [
          "String: String"
        ],
        "description": ""
      }
    },
    "ShaderNodeTexChecker": {
      "ShaderNodeTexChecker": {
        "inputs": [
          "Vector: Vector",
          "Color1: Color",
          "Color2: Color",
          "Scale: Float"
        ],
        "outputs": [
          "Color: Color",
          "Fac: Float"
        ],
        "description": "Generate a checkerboard texture"
      }
    },
    "ShaderNodeTexBrick": {
      "ShaderNodeTexBrick": {
        "inputs": [
          "Vector: Vector",
          "Color1: Color",
          "Color2: Color",
          "Mortar: Color",
          "Scale: Float",
          "Mortar Size: Float",
          "Mortar Smooth: Float",
          "Bias: Float",
          "Brick Width: Float",
          "Row Height: Float"
        ],
        "outputs": [
          "Color: Color",
          "Fac: Float"
        ],
        "description": "Generate a procedural texture producing bricks"
      }
    },
    "ShaderNodeTexNoise": {
      "ShaderNodeTexNoise": {
        "inputs": [
          "Vector: Vector",
          "W: Float",
          "Scale: Float",
          "Detail: Float",
          "Roughness: FloatFactor",
          "Lacunarity: Float",
          "Offset: Float",
          "Gain: Float",
          "Distortion: Float"
        ],
        "outputs": [
          "Fac: Float",
          "Color: Color"
        ],
        "description": "Generate fractal Perlin noise"
      }
    },
    "ShaderNodeTexVoronoi": {
      "ShaderNodeTexVoronoi": {
        "inputs": [
          "Vector: Vector",
          "W: Float",
          "Scale: Float",
          "Detail: Float",
          "Roughness: FloatFactor",
          "Lacunarity: Float",
          "Smoothness: FloatFactor",
          "Exponent: Float",
          "Randomness: FloatFactor"
        ],
        "outputs": [
          "Distance: Float",
          "Color: Color",
          "Position: Vector",
          "W: Float",
          "Radius: Float"
        ],
        "description": "Generate Worley noise based on the distance to random points. Typically used to generate textures such as stones, water, or biological cells"
      }
    },
    "ShaderNodeTexWhiteNoise": {
      "ShaderNodeTexWhiteNoise": {
        "inputs": [
          "Vector: Vector",
          "W: Float"
        ],
        "outputs": [
          "Value: Float",
          "Color: Color"
        ],
        "description": "Return a random value or color based on an input seed"
      }
    },
    "ShaderNodeTexGabor": {
      "ShaderNodeTexGabor": {
        "inputs": [
          "Vector: Vector",
          "Scale: Float",
          "Frequency: Float",
          "Anisotropy: FloatFactor",
          "Orientation: FloatAngle",
          "Orientation: VectorDirection"
        ],
        "outputs": [
          "Value: Float",
          "Phase: Float",
          "Intensity: Float"
        ],
        "description": "Generate Gabor noise"
      }
    },
    "ShaderNodeVectorMath": {
      "ShaderNodeVectorMath": {
        "inputs": [
          "Vector: Vector",
          "Vector: Vector",
          "Vector: Vector",
          "Scale: Float"
        ],
        "outputs": [
          "Vector: Vector",
          "Value: Float"
        ],
        "description": "Perform vector math operation"
      }
    },
    "ShaderNodeClamp": {
      "ShaderNodeClamp": {
        "inputs": [
          "Value: Float",
          "Min: Float",
          "Max: Float"
        ],
        "outputs": [
          "Result: Float"
        ],
        "description": "Clamp a value between a minimum and a maximum"
      }
    },
    "ShaderNodeMath": {
        "ShaderNodeMath": {
          "inputs": [
            "Value: Float",
            "Value: Float",
            "Value: Float"
          ],
          "outputs": [
            "Value: Float"
          ],
          "description": "Perform math operations"
        }
      }
  }